# A0133662J
###### src\main\paddletask\command\api\EditTaskCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import java.time.LocalDateTime;

import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.FloatingTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.Task.RECUR_TYPE;
import main.paddletask.task.entity.TimedTask;

import main.paddletask.common.exception.InvalidCommandFormatException;
import main.paddletask.common.exception.InvalidPriorityException;
import main.paddletask.common.exception.NoSuchTaskException;
import main.paddletask.common.exception.UpdateTaskException;
import main.paddletask.common.util.DateTimeHelper;

public class EditTaskCommand extends Command {

    /*** Variables ***/
    private static final Logger LOGGER = Logger.getLogger(EditTaskCommand.class.getName());
    private static final String TASK_TYPE_DEADLINE = "deadline";
    private static final String TASK_TYPE_TIMED = "timed";
    private static final String TASK_TYPE_FLOATING = "floating";
    private static final String TASK_TYPE_INVALID = "invalid";
    
    private static final String ERROR_MSG_GENERIC = "Error has occurred due to unexpected behavior";
    private static final String ERROR_MSG_ADD_START_TO_FLOAT = "You cannot add only a start Time/Date to a Floating Task!";
    private static final String ERROR_MSG_NO_SUCH_TASK = "Task with the following Task ID does not exist!";
    private static final String ERROR_MSG_UPDATE_TASK_FAIL = "Failed to store updated Task to Storage";
    private static final String ERROR_MSG_INVALID_PRIORITY = "The priority specified is invalid!";
    
    private static final String LOG_MSG_INFO_STORE_TASK = "EditTaskCommand: Storing updated task to Storage\n";
    private static final String LOG_MSG_SEVERE_GET_TASK_FAIL = "Executing EditTaskCommand getTaskFromStorage(): Retrieve Task with taskId -> %1s failed";
    private static final String LOG_MSG_SEVERE_STORE_TASK_FAIL = "Executing EditTaskCommand storeTaskToStorage(): Storing Task with taskId -> %1s failed";
    private static final String LOG_MSG_SEVERE_ADD_START_TO_FLOAT = "Executing EditTaskCommand: User attempt to add only start date/time to Floating Task";
    
    private static final int PRIORITY_MIN_LEVEL = 1;
    private static final int PRIORITY_MAX_LEVEL = 3;
    private static final int PRIORITY_NONE = -1;
    
    private ArrayList<Task> _executionResult;
    private int _taskId;
    private int _newPriority;
    private boolean _isValidEditCommand;
    private boolean _newRecurStatus;
    private RECUR_TYPE _newRecurType;
    private Task _originalTask;
    private Task _editedTask;
    private String _originalTaskType;
    private String _newDescription;
    private LocalDateTime _newStart;
    private LocalDateTime _newEnd;
    private LocalDateTime _newReminder;

    public EditTaskCommand() {
        _originalTaskType = null;
        _newDescription = null;
        _newStart = null;
        _newEnd = null;
        _newReminder = null;
        _newPriority = -1;
        _newRecurStatus = false;
        _isValidEditCommand = true;
        _executionResult = new ArrayList<Task>();
    }

    /*** Methods ***/
    /**
     * This method modifies a Task based on user input for the edit command
     * 
     * @return an ArrayList of Task objects that contains the modified Task
     *         object
     * @throws Exception 
     */
    @Override
    public ArrayList<Task> execute() throws Exception {
        retrieveOptions();
        getTaskFromStorage(_taskId);
        determineOriginalTaskType();
        createEditedTask();
        prepareExecutionResult();
        
        return _executionResult;
    }

    /**
     * This method reverse the previous execute() of the previous
     * EditTaskCommand
     * 
     * @return an ArrayList of Task objects that contains the modified Task
     *         object
     * @throws UpdateTaskException
     */
    public ArrayList<Task> undo() throws UpdateTaskException {
        prepareUndoTask();
        prepareExecutionResult();
        
        return _executionResult;
    }

    /**
     * This method modifies a Task based on user input for the edit command
     * 
     * @throws UpdateTaskException
     */
    private void prepareExecutionResult() throws UpdateTaskException {
        if (_isValidEditCommand) {
            _executionResult.clear();
            _executionResult.add(_editedTask);
            storeTaskToStorage(_editedTask);
        } else {
            _executionResult = null;
        }
    }
    
    /**
     * This method retrieves the parsed parameters stored in the Option object
     * in this EditTaskCommand
     */
    private void retrieveOptions() {
        setTaskIdOption();
        setNewDescriptionOption();
        setNewStartOption();
        setNewEnd();
        setNewReminder();
        setNewPriority();
        setNewRecurStatus();
    }

    private void prepareUndoTask() {
        Task temp = _editedTask;
        _editedTask = _originalTask;
        _originalTask = temp;
    }
    
    private void setTaskIdOption() {
        _taskId = getOption("edit").getIntegerValue();
    }

    private void setNewPriority() {
        if (hasOption("priority")) {
            _newPriority = getOption("priority").getIntegerValue();
        }
    }

    private void setNewReminder() {
        if (hasOption("remind")) {
            _newReminder = getOption("remind").getDateValue();
        }
    }

    private void setNewEnd() {
        if (hasOption("end")) {
            _newEnd = getOption("end").getDateValue();
        }
    }

    private void setNewStartOption() {
        if (hasOption("start")) {
            _newStart = getOption("start").getDateValue();
        }
    }

    private void setNewDescriptionOption() {
        if (hasOption("desc")) {
            _newDescription = getOption("desc").getStringValue();
        }
    }

    private void setNewRecurStatus() {
        if (hasOption("every")) {
            _newRecurStatus = true;
            _newRecurType = Task.determineRecurType(getOption("every").getStringValue());
        }
    }
    
    private void determineOriginalTaskType() {
        switch (_originalTask.getType()) {
        case FLOATING :
            _originalTaskType = TASK_TYPE_FLOATING;
            break;
        case DEADLINE :
            _originalTaskType = TASK_TYPE_DEADLINE;
            break;
        case TIMED :
            _originalTaskType = TASK_TYPE_TIMED;
            break;
        default :
            _originalTaskType = TASK_TYPE_INVALID;
            _isValidEditCommand = false;
        }
    }

    /**
     * Instantiates the task object to be modified to the appropriate Task type
     * with the appropriate attributes
     * @throws Exception 
     */
    private void createEditedTask() throws Exception {
        switch (determineEditedTaskType()) {
            case TASK_TYPE_FLOATING :
                createNewFloatingTask();
                break;
            case TASK_TYPE_DEADLINE :
                createNewDeadlineTask();
                break;
            case TASK_TYPE_TIMED :
                createNewTimedTask();
                break;    
            case TASK_TYPE_INVALID :
                throw new Exception(ERROR_MSG_GENERIC);
        }
    }

    /**
     * Determines the resulting Task type of the Task object to be modified
     * based on user input from the edit command
     * 
     * @return a String that indicates the appropriate Task type for the Task
     *         object to be modified
     * @throws Exception 
     */
    private String determineEditedTaskType() throws Exception {
        switch (_originalTaskType) {
            case TASK_TYPE_FLOATING :
                // If no start/end date/time is specified, task.type is still Floating
                if (_newStart == null && _newEnd == null) {
                    return TASK_TYPE_FLOATING;
                 // If only an end date/time is specified, task.type is now a Deadline task
                } else if (_newStart == null) { 
                    return TASK_TYPE_DEADLINE;
                 // If both new and end date/time is specified, task.type is now a Timed task
                } else if (_newStart != null && _newEnd != null) {
                    return TASK_TYPE_TIMED;
                } else if (_newStart != null && _newEnd == null) {
                    LOGGER.log(Level.SEVERE, LOG_MSG_SEVERE_ADD_START_TO_FLOAT);
                    throw new InvalidCommandFormatException(ERROR_MSG_ADD_START_TO_FLOAT);
                }
    
            case TASK_TYPE_DEADLINE :
                if (_newStart == null) {
                    return TASK_TYPE_DEADLINE;
                } else {
                    return TASK_TYPE_TIMED;
                }
    
            case TASK_TYPE_TIMED :
                return TASK_TYPE_TIMED;
    
            default :
                throw new Exception(ERROR_MSG_GENERIC);
        }
    }
    
    private void createNewFloatingTask() throws InvalidPriorityException {
        _editedTask = new FloatingTask(_originalTask.getTaskId(), getEditedTaskDescription(),
                _originalTask.getCreatedAt(), _originalTask.isComplete(), getEditedTaskPriority(),
                _originalTask.getTags());
    }

    private void createNewDeadlineTask() throws Exception {
        _editedTask = new DeadlineTask(_originalTask.getTaskId(), getEditedTaskDescription(),
                _originalTask.getCreatedAt(), getEditedTaskEnd(), getEditedTaskReminder(), _originalTask.isComplete(),
                getEditedTaskPriority(), _originalTask.getTags(),getEditedTaskRecurStatus(), getEditedTaskRecurType());
    }

    private void createNewTimedTask() throws Exception {
        _editedTask = new TimedTask(_originalTask.getTaskId(), getEditedTaskDescription(), _originalTask.getCreatedAt(),
                getEditedTaskStart(), getEditedTaskEnd(), getEditedTaskReminder(), _originalTask.isComplete(),
                getEditedTaskPriority(), _originalTask.getTags(),getEditedTaskRecurStatus(), getEditedTaskRecurType());
    }

    /*** Setter and Getter Methods ***/
    
    private String getEditedTaskDescription() {
        // If user specified a new description, use this
        if (_newDescription != null) {
            return _newDescription;
        } else {
            // Otherwise, use the original description
            return _originalTask.getDescription();
        }
    }

    private LocalDateTime getEditedTaskStart() {
        // If user specified a new Start date/time, use this
        if (_newStart != null) {
            return _newStart;
        } else {
            // Otherwise, retrieve original Task casted to a TimedTask as only this Task
            // type has Start date/time
            return getTimedTaskCastedOriginalTask().getStart();
        }
    }

    private LocalDateTime getEditedTaskEnd() {
        LocalDateTime newEditedTaskEnd = null;
        // If user specified a new End date/time, use this
        if (_newEnd != null) {
            // If user did not specify a new Reminder, change it to a time that is 
            // 5 minutes before the new specified End/date time
            if (_newReminder == null) {
                _newReminder = DateTimeHelper.addMinutes(_newEnd, -5);
            }
            return _newEnd;
        } else if (isOriginalTaskDeadline()) {
            // Otherwise, if this Task is a DeadlineTask, get DeadlineTask casted original 
            // Task and retrieve the End date/time
            newEditedTaskEnd = getDeadlineTaskCastedOriginalTask().getEnd();
        } else if (isOriginalTaskTimed()) {
            // Otherwise, if this Task is a TimedTask, get TimedTask casted original 
            // Task and retrieve the End date/time
            newEditedTaskEnd = getTimedTaskCastedOriginalTask().getEnd();
        }
        
        return newEditedTaskEnd;
    }

    private LocalDateTime getEditedTaskReminder() {
        LocalDateTime newEditedTaskReminder = null;
        // If user specified a new Reminder LocalDateTime, use this
        if (_newReminder != null) {
            return _newReminder;
        } else if (isOriginalTaskFloating()) {
            // Otherwise, if this Task is a Floating Task, set a new Reminder that will
            // be 5 minutes before the End date/time
            newEditedTaskReminder = DateTimeHelper.addMinutes(getEditedTaskEnd(), -5);
        } else if (isOriginalTaskDeadline()) {
            // Otherwise, if this Task is a DeadlineTask, get the DeadlineTask casted
            // original Task and retrieve its original Reminder
            newEditedTaskReminder = getDeadlineTaskCastedOriginalTask().getReminder();
        } else if (isOriginalTaskTimed()) {
            // Otherwise, if this Task is a TimedTask, get the TimedTask casted
            // original Task and retrieve its original Reminder
            newEditedTaskReminder = getTimedTaskCastedOriginalTask().getReminder();
        }
        
        return newEditedTaskReminder;
    }

    private int getEditedTaskPriority() throws InvalidPriorityException {
        if (_newPriority == PRIORITY_NONE) {
            return _originalTask.getPriority();
        } else if (_newPriority < PRIORITY_MIN_LEVEL || _newPriority > PRIORITY_MAX_LEVEL) {
            // If new user specified priority is beyond the valid range [1..3], throw Error
            throw new InvalidPriorityException(ERROR_MSG_INVALID_PRIORITY);
        } else {
            return _newPriority;
        }
    }

    private boolean getEditedTaskRecurStatus() throws Exception {
        boolean newEditedRecurStatus;
        if (_newRecurStatus != false) {
            return true;
        } else if (isOriginalTaskFloating()) {
            newEditedRecurStatus = false;
        } else if (isOriginalTaskDeadline()) {
            newEditedRecurStatus = getDeadlineTaskCastedOriginalTask().isRecurring();
        } else if (isOriginalTaskTimed()) {
            newEditedRecurStatus = getTimedTaskCastedOriginalTask().isRecurring();
        } else {
            throw new Exception(ERROR_MSG_GENERIC);
        }
        return newEditedRecurStatus;
    }
    
    private RECUR_TYPE getEditedTaskRecurType() throws Exception {
        RECUR_TYPE newEditedRecurType;
        if (_newRecurStatus != false) {
            return _newRecurType;
        } else if (isOriginalTaskFloating()) {
            return newEditedRecurType = RECUR_TYPE.NULL;
        } else if (isOriginalTaskDeadline()) {
            newEditedRecurType = getDeadlineTaskCastedOriginalTask().getRecurPeriod();
        } else if (isOriginalTaskTimed()) {
            newEditedRecurType = getTimedTaskCastedOriginalTask().getRecurPeriod();
        } else {
            // Error has occur
            throw new Exception(ERROR_MSG_GENERIC);
        }
        return newEditedRecurType;
    }
    
    private DeadlineTask getDeadlineTaskCastedOriginalTask() {
        DeadlineTask castedOriginalTask = (DeadlineTask) _originalTask;
        
        return castedOriginalTask;
    }

    private TimedTask getTimedTaskCastedOriginalTask() {
        TimedTask castedOriginalTask = (TimedTask) _originalTask;
        
        return castedOriginalTask;
    }

    /**
     * This method calls the storageAPI to retrieve the Task object with this taskId
     * 
     * @param taskId
     *            the id of the Task object to retrieve
     * @throws NoSuchTaskException
     */
    private void getTaskFromStorage(int taskId) throws NoSuchTaskException {
        _originalTask = TaskController.getInstance().getTask(taskId);
        if (_originalTask == null) {
            LOGGER.log(Level.SEVERE,String.format(LOG_MSG_SEVERE_GET_TASK_FAIL, taskId));
            throw new NoSuchTaskException(ERROR_MSG_NO_SUCH_TASK);
        }
    }

    private boolean isOriginalTaskFloating() {
        return _originalTaskType.equals(TASK_TYPE_FLOATING);
    }
    
    private boolean isOriginalTaskDeadline() {
        return _originalTaskType.equals(TASK_TYPE_DEADLINE);
    }
    
    private boolean isOriginalTaskTimed() {
        return _originalTaskType.equals(TASK_TYPE_TIMED);
    }
    /**
     * This method calls the storageAPI to store this Task object
     * 
     * @param task
     *            the Task object that is updated
     * @throws UpdateTaskException
     */
    private void storeTaskToStorage(Task task) throws UpdateTaskException {
        LOGGER.info(LOG_MSG_INFO_STORE_TASK);
        if (!TaskController.getInstance().updateTask(task)) {
            LOGGER.log(Level.SEVERE, String.format(LOG_MSG_SEVERE_STORE_TASK_FAIL, _taskId));
            throw new UpdateTaskException(ERROR_MSG_UPDATE_TASK_FAIL);
        }
    }
}
```
###### src\main\paddletask\command\api\TagTaskCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.paddletask.common.exception.NoSuchTaskException;
import main.paddletask.common.exception.UpdateTaskException;

import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.Task;

public class TagTaskCommand extends Command {

    /*** Variables ***/
    private static final Logger LOGGER = Logger.getLogger(EditTaskCommand.class.getName());
    
    private static final String ERROR_MSG_NO_SUCH_TASK = "Task with the following Task ID does not exist!";
    private static final String ERROR_MSG_UPDATE_TASK_FAIL = "Failed to store updated Task to Storage";
    
    private static final String LOG_MSG_INFO_STORE_TASK = "TagTaskCommand: Storing updated task to Storage\n";
    private static final String LOG_MSG_SEVERE_GET_TASK_FAIL = "Executing TagTaskCommand: Retrieve Task with taskId -> %1s failed";
    private static final String LOG_MSG_SEVERE_STORE_TASK_FAIL = "Executing TaskTaskCommand: storeTaskToStorage(): Storing Task with taskId -> %1s failed\n";
    
    private ArrayList<String> _tagsToAdd;
    private ArrayList<String> _modifiedTaglist;
    private ArrayList<String> _originalTaglist;
    private ArrayList<Task> _executionResult;
    private Task _taskToEdit;
    private int _taskId;

    public TagTaskCommand() {
        _modifiedTaglist = new ArrayList<String>();
        _tagsToAdd = new ArrayList<String>();
        _executionResult = new ArrayList<Task>();
    }

    @Override
    public ArrayList<Task> execute() throws Exception {
        retrieveOptions();
        getTaskFromStorage(_taskId);
        processTags();
        prepareExecutionResult();
        return _executionResult;
    }

    @Override
    public ArrayList<Task> undo() throws Exception {
        prepareUndoTags();
        prepareExecutionResult();
        return _executionResult;
    }

    private void retrieveOptions() {
        setTaskIdOption();
        setTagsToAddOption();
    }

    private void prepareExecutionResult() throws UpdateTaskException {
        assert _modifiedTaglist != null;
        saveTagToTask(_modifiedTaglist);

        assert _taskToEdit != null;
        _executionResult.add(_taskToEdit);
    }

    private void prepareUndoTags() {
        ArrayList<String> temp = _originalTaglist;
        _originalTaglist = _modifiedTaglist;
        _modifiedTaglist = temp;
    }

    private void processTags() throws UpdateTaskException {
        archiveOriginalTags(getExistingTags());
        updateOriginalTags();
    }

    private void updateOriginalTags() {
        _modifiedTaglist = getExistingTags();
        
        for (String tagToAdd : _tagsToAdd) {
            boolean hasTag = false;
            for (String existingTag : _originalTaglist) {
                if (tagToAdd.equalsIgnoreCase(existingTag)) {
                    hasTag = true;
                }
            }
            
            if (!hasTag) {
                _modifiedTaglist.add(tagToAdd);
            }
        }
    }

    private void archiveOriginalTags(ArrayList<String> existingTags) {
        _originalTaglist = new ArrayList<String>();
        
        for (String existingTag : existingTags) {
            _originalTaglist.add(existingTag);
        }
    }

    private ArrayList<String> getExistingTags() {
        assert _taskToEdit != null;
        ArrayList<String> existingTags = _taskToEdit.getTags();
        
        return existingTags;
    }

    private void setTaskIdOption() {
        _taskId = getOption("tag").getIntegerValue();
    }
    
    private void setTagsToAddOption() {
        if (hasOption("#")) {
            int numTags = getOption("#").getValuesCount();
            for (int i = 0; i < numTags; i++) {
                _tagsToAdd.add((getOption("#").getStringValue(i)));
            }
        }
    }
    
    private void saveTagToTask(ArrayList<String> updatedTaskTags) throws UpdateTaskException {
        assert _taskToEdit != null;
        _taskToEdit.setTags(updatedTaskTags);
        storeTaskToStorage(_taskToEdit);
    }

    private void getTaskFromStorage(int taskId) throws NoSuchTaskException {
        _taskToEdit = TaskController.getInstance().getTask(taskId);
        
        if (_taskToEdit == null) {
            LOGGER.log(Level.SEVERE, String.format(LOG_MSG_SEVERE_GET_TASK_FAIL, taskId));
            throw new NoSuchTaskException(ERROR_MSG_NO_SUCH_TASK);
        }
    }

    private void storeTaskToStorage(Task task) throws UpdateTaskException {
        LOGGER.info(LOG_MSG_INFO_STORE_TASK);
        if (!TaskController.getInstance().updateTask(task)) {
            LOGGER.log(Level.SEVERE, String.format(LOG_MSG_SEVERE_STORE_TASK_FAIL, _taskId));
            throw new UpdateTaskException(ERROR_MSG_UPDATE_TASK_FAIL);
        }
    }
}
```
###### src\main\paddletask\command\api\UntagTaskCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.paddletask.common.exception.NoSuchTaskException;
import main.paddletask.common.exception.UpdateTaskException;

import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.Task;

public class UntagTaskCommand extends Command {

    /*** Variables ***/
    private static final Logger LOGGER = Logger.getLogger(TagTaskCommand.class.getName());
    
    private static final String ERROR_MSG_NO_SUCH_TASK = "Task with the following Task ID does not exist!";
    private static final String ERROR_MSG_UPDATE_TASK_FAIL = "Failed to store updated Task to Storage";
    
    private static final String LOG_MSG_INFO_STORE_TASK = "UntagTaskCommand: Storing updated task to Storage\n";
    private static final String LOG_MSG_SEVERE_GET_TASK_FAIL = "Executing UntagTaskCommand: Retrieve Task with taskId -> %1s failed";
    private static final String LOG_MSG_SEVERE_STORE_TASK_FAIL = "Executing UntagTaskCommand: storeTaskToStorage(): Storing Task with taskId -> %1s failed\n";
    
    private ArrayList<String> _tagsToRemove;
    private ArrayList<String> _modifiedTaglist;
    private ArrayList<String> _originalTaglist;
    private ArrayList<Task> _executionResult;
    private Task _taskToEdit;
    private static int _taskId;

    public UntagTaskCommand() {
        _modifiedTaglist = new ArrayList<String>();
        _tagsToRemove = new ArrayList<String>();
        _executionResult = new ArrayList<Task>();
    }

    /*** Methods ***/

    @Override
    public ArrayList<Task> execute() throws Exception {
        retrieveOptions();
        getTaskFromStorage(_taskId);
        processTags();
        prepareExecutionResult();
        return _executionResult;
    }

    public void retrieveOptions() {
        setTaskIdOption();
        setTagsToRemoveOption();
    }

    public void prepareExecutionResult() throws UpdateTaskException {
        assert _modifiedTaglist != null;
        saveTagToTask(_modifiedTaglist);

        assert _taskToEdit != null;
        _executionResult.add(_taskToEdit);
    }

    @Override
    public ArrayList<Task> undo() throws Exception {
        prepareUndoTags();
        prepareExecutionResult();
        return _executionResult;
    }

    private void prepareUndoTags() {
        ArrayList<String> temp = _originalTaglist;
        _originalTaglist = _modifiedTaglist;
        _modifiedTaglist = temp;
    }

    private void processTags() throws UpdateTaskException {
        archiveOriginalTaglist(getExistingTaglist());
        updateOriginalTaglist();
    }

    private void updateOriginalTaglist() {
        _modifiedTaglist = getExistingTaglist();
        _modifiedTaglist.removeAll(_tagsToRemove);
    }

    private void archiveOriginalTaglist(ArrayList<String> existingTags) {
        _originalTaglist = new ArrayList<String>();
        
        for (String existingTag : existingTags) {
            _originalTaglist.add(existingTag);
        }
    }

    private ArrayList<String> getExistingTaglist() {
        assert _taskToEdit != null;
        ArrayList<String> existingTags = _taskToEdit.getTags();
        
        return existingTags;
    }

    private void setTaskIdOption() {
        _taskId = getOption("untag").getIntegerValue();
    }
    
    private void setTagsToRemoveOption() {
        if (hasOption("#")) {
            int numTags = getOption("#").getValuesCount();
            for (int i = 0; i < numTags; i++) {
                _tagsToRemove.add((getOption("#").getStringValue(i)));
            }
        }
    }
    
    private void saveTagToTask(ArrayList<String> updatedTaskTags) throws UpdateTaskException {
        assert _taskToEdit != null;
        _taskToEdit.setTags(updatedTaskTags);
        storeTaskToStorage(_taskToEdit);
    }

    private void getTaskFromStorage(int taskId) throws NoSuchTaskException {
        _taskToEdit = TaskController.getInstance().getTask(taskId);
        if (_taskToEdit == null) {
            LOGGER.log(Level.SEVERE, String.format(LOG_MSG_SEVERE_GET_TASK_FAIL, taskId));
            throw new NoSuchTaskException(ERROR_MSG_NO_SUCH_TASK);
        }
    }

    private void storeTaskToStorage(Task task) throws UpdateTaskException {
        LOGGER.info(LOG_MSG_INFO_STORE_TASK);
        if (!TaskController.getInstance().updateTask(task)) {
            LOGGER.log(Level.SEVERE, String.format(LOG_MSG_SEVERE_STORE_TASK_FAIL, _taskId));
            throw new UpdateTaskException(ERROR_MSG_UPDATE_TASK_FAIL);
        }
    }

}
```
###### src\main\paddletask\common\data\SearchResult.java
``` java
package main.paddletask.common.data;

import main.paddletask.task.entity.Task;

public class SearchResult implements Comparable<SearchResult> {
	
	private Integer matchCount;
	private Task matchedTask;

	public SearchResult(Integer _matchCount, Task _matchedTask) {
		matchCount = _matchCount;
		matchedTask = _matchedTask;
	}
	
	public Integer getMatchCount() {
		return matchCount;
	}
	
	public Task getMatchedTask() {
		return matchedTask;
	}

	@Override
	public int compareTo(SearchResult o) {
		int thisId = this.getMatchedTask().getTaskId();
		int oId = o.getMatchedTask().getTaskId();
		String thisDescription = this.getMatchedTask().getDescription();
		String oDescription = this.getMatchedTask().getDescription();
		
		if (!this.getMatchCount().equals(o.getMatchCount())) {
			return o.getMatchCount() - this.getMatchCount();
		} else if (!thisDescription.equals(oDescription)) {
			return oDescription.compareTo(thisDescription);
		} else {
			return thisId - oId;
		}
	}
}
```
###### src\main\paddletask\common\exception\NoSuchTaskException.java
``` java
package main.paddletask.common.exception;

@SuppressWarnings("serial")
public class NoSuchTaskException extends PaddleTaskException {
	
	public NoSuchTaskException(String message) {
		super(message);
	}
	
}
```
###### src\main\paddletask\logic\api\LogicController.java
``` java
package main.paddletask.logic.api;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Observable;
import java.util.Observer;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.paddletask.command.api.Command;
import main.paddletask.command.api.SearchTaskCommand;

import main.paddletask.common.exception.NoTaskStateException;

import main.paddletask.parser.api.CommandParser;

import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.TaskComparator;

public class LogicController extends Observable {

    /*** Variable ***/
    private static final Logger LOGGER = Logger.getLogger(LogicController.class.getName());
    
    private static final String LOG_MSG_INFO_INIT_LOGIC_CONTROLLER = "Intialising LogicController";
    private static final String LOG_MSG_SEVERE_NO_TASK_STATE = "LogicController:parseCommand(): Attempt to read state when there are no tasks";
    
    private static final String ERROR_MSG_NO_TASK_STATE = "Please perform a view to retrieve a list of task so that you can perform this command!";
    
    private static LogicController _thisInstance;
    private static CommandParser _parserInstance;
    private static TaskComparator _taskComparatorInstance;
    private static ArrayList<Task> _deliveredTaskState;
    private static Observer _observer;

    /*** Constructor ***/
    public LogicController() {
        LOGGER.info(LOG_MSG_INFO_INIT_LOGIC_CONTROLLER);
        _parserInstance = new CommandParser();
        _deliveredTaskState = new ArrayList<Task>();
        _taskComparatorInstance = new TaskComparator();
    }

    /*** Methods ***/

    /**
     * Retrieves a Singleton instance of a LogicController
     * 
     * @param mainObserver
     *          The observer view passed from the caller
     * @return an instance of LogicController
     */
    public static LogicController getInstance(Observer mainObserver) {
        if (_thisInstance == null) {
            _observer = mainObserver;
            _thisInstance = new LogicController();
        }
        
        return _thisInstance;
    }
    
    // API for UI component to access LogicController
    public ArrayList<Task> processCommand(String userInput) {
        return handleCommand(userInput);
    }

    private Command parseCommand(String userInput) throws Exception {
        assert(userInput != null);
        Command command;
        // If userinput is a command that requires the state such as "edit <running index>"
        // or "delete <running index>", send both the user input and the state to the Parser
        if (_parserInstance.isStatefulCommand(userInput)) {
            if (_deliveredTaskState.isEmpty()) {
                LOGGER.log(Level.SEVERE, LOG_MSG_SEVERE_NO_TASK_STATE);
                throw new NoTaskStateException(ERROR_MSG_NO_TASK_STATE);
            } else {
                command = _parserInstance.parse(userInput, getStateTaskId());
            }
        } else {
            // Otherwise, send only the user input to the Parser
            command = _parserInstance.parse(userInput);
        }

        return command;
    }

    private ArrayList<Task> executeCommand(Command command, String userInput) throws Exception {
        command.addObserver(_observer);
        ArrayList<Task> executionResult = new ArrayList<Task>();
        
        // If userinput is a Command that will update the state such as "view all"
        // or "search <sequence>", execute the Command and update the state with the result
        if (_parserInstance.isSaveStateCommand(userInput)) {
            executionResult = command.execute();
            // If the Command is a "Search", sort the results based on degree of match
            // details specified in TaskComparator implementation
            if (!isSearch(command)) {
                Collections.sort(executionResult, _taskComparatorInstance);
            }
            _deliveredTaskState = executionResult;
        } else {
            // Otherwise, execute all other Command without updating the state
            // with the result
            executionResult = command.execute();
        }
        
        return executionResult;
    }

    private ArrayList<Task> handleCommand(String userInput) {
        ArrayList<Task> executionResult;
        Command command;
        // Attempt to parse and execute the Command specified by user input
        try {
            command = parseCommand(userInput);
            executionResult = executeCommand(command, userInput);
        } catch (Exception e) {
            // If an Exception is encounted during the Command parsing or
            // Command execution, update the observer with the Error messages
            setChanged();
            notifyObservers(e.getMessage());
            return null;
        }
        
        return executionResult;
    }

    // Pull out the task ID of all Task in the state so that it can be 
    // passed to the Parser for stateful command parsing
    private int[] getStateTaskId() {
        int numId = _deliveredTaskState.size();
        int[] stateIndexes = new int[numId];
        for (int i = 0; i < numId; i++) {
            stateIndexes[i] = _deliveredTaskState.get(i).getTaskId();
        }
        
        return stateIndexes;
    }

    private boolean isSearch(Command command) {
        if (command instanceof SearchTaskCommand) {
            return true;
        } else {
            return false;
        }
    }
}
```
###### src\main\paddletask\task\entity\TaskComparator.java
``` java
package main.paddletask.task.entity;

import java.time.LocalDateTime;
import java.util.Comparator;

import main.paddletask.task.entity.Task.TASK_TYPE;

public class TaskComparator implements Comparator<Task> {

	@Override
	public int compare(Task o1, Task o2) {
		if (o1.getPriority() != o2.getPriority()) {
			return o1.getPriority() - o2.getPriority();
		} else if (!o1.getType().equals(TASK_TYPE.FLOATING) && !o2.getType().equals(TASK_TYPE.FLOATING)) {
			return getTaskEnd(o1).compareTo(getTaskEnd(o2));
		} else if (!o1.getType().equals(TASK_TYPE.FLOATING) && o2.getType().equals(TASK_TYPE.FLOATING)) {
			return -1;
		} else if (o1.getType().equals(TASK_TYPE.FLOATING) && !o2.getType().equals(TASK_TYPE.FLOATING)) {
			return 1;
		} else {
			return o1.getTaskId() - o2.getTaskId();
		}
	}

	private LocalDateTime getTaskEnd(Task task) {
		if (task.getType().equals(TASK_TYPE.DEADLINE)) {
			return castToDeadline(task).getEnd();
		} else if (task.getType().equals(TASK_TYPE.TIMED)) {
			return castToTimed(task).getEnd();
		} else {
			return null;
		}
	}
	
	private DeadlineTask castToDeadline(Task task) {
		return (DeadlineTask) task;
	}
	
	private TimedTask castToTimed(Task task) {
		return (TimedTask) task;
	}
}
```
###### src\test\cases\TestEditTaskCommand.java
``` java
package test.cases;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;
import org.w3c.dom.Document;

import main.paddletask.command.api.EditTaskCommand;
import main.paddletask.command.api.ViewTaskCommand;
import main.paddletask.storage.api.StorageController;
import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.FloatingTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.TimedTask;
import main.paddletask.parser.api.CommandParser;
import main.paddletask.common.util.DateTimeHelper;

public class TestEditTaskCommand {
    /*
     * Test Assumption: 1. StorageController is working correctly 2.
     * TaskController is working correctly 3. CommandParser is working correctly
     */

    /*** Variables ***/
    protected static ArrayList<Task> testTaskList;
    protected static ArrayList<Task> testStateList;
    protected static StorageController storageControllerInstance;
    protected static TaskController taskControllerInstance;
    protected static CommandParser commandParserInstance;
    protected static int[] stateTaskId;

    protected static String dummy_userCommand;
    protected static EditTaskCommand dummy_editTaskCommand;
    protected static FloatingTask dummy_floatingTask;
    protected static DeadlineTask dummy_deadlineTask;
    protected static TimedTask dummy_timedTask;
    protected static Task dummy_genericTask;

    protected static final String WHITE_SPACE = " ";
    protected static final String TEST_COMMAND = "edit %1s%2s%3s%4s%5s"; // id,
                                                                         // description,
                                                                         // end,
                                                                         // start,
                                                                         // reminder

    protected static final int TEST_SAMPLE_FLOAT_ID = 1;
    protected static final int TEST_SAMPLE_DEADLINE_ID = 2;
    protected static final int TEST_SAMPLE_TIMED_ID = 3;

    protected static final String TEST_SAMPLE_DESCRIPTION = "Lorem ipsum dolor";
    protected static final String TEST_SAMPLE_END_DATE = "25/12/2015";
    protected static final String TEST_SAMPLE_END_TIME = "12:30";
    protected static final String TEST_SAMPLE_START_DATE = "24/12/2015";
    protected static final String TEST_SAMPLE_START_TIME = "12:00";
    protected static final String TEST_SAMPLE_REMINDER_DATE_TIME = "20/12/2015 20:00";
    protected static final String TEST_KEYWORD_DESC = " desc ";
    protected static final String TEST_KEYWORD_END = " end ";
    protected static final String TEST_KEYWORD_START = " start ";
    protected static final String TEST_KEYWORD_REMIND = " remind ";
    protected static final String TEST_KEYWORD_EMPTY = "";

    protected static final Task.TASK_TYPE TEST_TASKTYPE_FLOATING = Task.TASK_TYPE.FLOATING;
    protected static final Task.TASK_TYPE TEST_TASKTYPE_DEADLINE = Task.TASK_TYPE.DEADLINE;
    protected static final Task.TASK_TYPE TEST_TASKTYPE_TIMED = Task.TASK_TYPE.TIMED;

    protected static final String TEST_EDIT_FLOATING_DESCRIPTION = "Test editing Floating Task description";
    protected static final String TEST_ADD_END_DATE_TO_FLOATING = "Test adding only an End date to a Floating Task";
    protected static final String TEST_ADD_END_DATE_AND_REMINDER_TO_FLOATING = "Test adding only an End date and a custom Reminder to a Floating Task";
    protected static final String TEST_ADD_END_TIME_TO_FLOATING = "Test adding only an End time to a Floating Task";
    protected static final String TEST_ADD_END_TIME_AND_REMINDER_TO_FLOATING = "Testing adding only an End time and a custom Reminder to a Floating Task";
    protected static final String TEST_ADD_END_DATE_TIME_TO_FLOATING = "Test adding both an End time and date to a Floating Task";
    protected static final String TEST_ADD_END_DATE_TIME_AND_REMINDER_TO_FLOATING = "Testing adding both an End time,date and a Reminder to a Floating task";

    protected static final String TEST_EDIT_DEADLINE_DESCRIPTION = "Test editing Deadline Task description";
    protected static final String TEST_EDIT_DEADLINE_END_DATE = "Test editing a Deadline Task's End date only";
    protected static final String TEST_EDIT_DEADLINE_END_DATE_AND_REMINDER = "Test editing a Deadline Task's End date and Reminder";
    protected static final String TEST_EDIT_DEADLINE_END_TIME = "Test editing a Deadline Task's End time only";
    protected static final String TEST_EDIT_DEADLINE_END_TIME_AND_REMINDER = "Test editing a Deadline Task's End time and Reminder";
    protected static final String TEST_EDIT_DEADLINE_END_DATE_TIME = "Test editing a Deadline Task's End date and time";
    protected static final String TEST_EDIT_DEADLINE_END_DATE_TIME_AND_REMINDER = "Test editing a Deadline Task's End date,time and Reminder";
    protected static final String TEST_ADD_START_DATE_TO_DEADLINE = "Test adding a Start date only to a Deadline Task";
    protected static final String TEST_ADD_START_TIME_TO_DEADLINE = "Test adding a Start time only to a Deadline Task";
    protected static final String TEST_ADD_START_DATE_TIME_TO_DEADLINE = "Test adding a Start date and time to a Deadline Task";

    protected static final String TEST_EDIT_TIMED_DESCRIPTION = "Test editing a Timed Task description";
    protected static final String TEST_EDIT_TIMED_END_DATE = "Test editing a Timed Task's End date only";
    protected static final String TEST_EDIT_TIMED_END_DATE_AND_REMINDER = "Test editing a Timed Task's End date and Reminder";
    protected static final String TEST_EDIT_TIMED_END_TIME = "Test editing a Timed Task's End time only";
    protected static final String TEST_EDIT_TIMED_END_TIME_AND_REMINDER = "Test editing a Timed Task's End time and Reminder";
    protected static final String TEST_EDIT_TIMED_END_DATE_TIME = "Test editing a Timed Task's End date and time";
    protected static final String TEST_EDIT_TIMED_START_DATE = "Test editing a Timed Task's Start date only";
    protected static final String TEST_EDIT_TIMED_START_TIME = "Test editing a Timed Task's Start time only";
    protected static final String TEST_EDIT_TIMED_START_DATE_TIME = "Test editing a Timed Task's Start date and time";

    /*** Setup ***/
    @Before
    public void setUp() throws Exception {
        storageControllerInstance = StorageController.getInstance();
        testTaskList = repopulateTask();
        taskControllerInstance = TaskController.getInstance();
        commandParserInstance = new CommandParser();
    }

    public ArrayList<Task> repopulateTask() throws Exception {
        ArrayList<Task> testTaskList = new ArrayList<Task>();
        commandParserInstance = new CommandParser();
        // Populate sample arraylist
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        Task task;
        task = new FloatingTask(1, "Get a good luck charm", DateTimeHelper.now(), false, 3);
        testTaskList.add(task);
        task = new DeadlineTask(2, "CS2103 CE2", DateTimeHelper.now(),
                LocalDateTime.parse("2015-01-02 23:59", formatter), DateTimeHelper.now(), false, 3, false,
                Task.RECUR_TYPE.NULL);
        testTaskList.add(task);
        task = new TimedTask(3, "Appointment with dentist", DateTimeHelper.now(),
                LocalDateTime.parse("2015-01-03 23:59", formatter), LocalDateTime.parse("2015-09-10 15:30", formatter),
                DateTimeHelper.now(), false, 3, false, Task.RECUR_TYPE.NULL);
        testTaskList.add(task);
        Document doc = storageControllerInstance.parseTask(testTaskList);
        storageControllerInstance.writeXml(doc);
        initTaskState();
        return testTaskList;
    }

    public void initTaskState() throws Exception {
        String viewInputCommand = "view";
        ViewTaskCommand viewCommand = (ViewTaskCommand) commandParserInstance.parse(viewInputCommand);
        testStateList = viewCommand.execute();
    }

    public int[] initStateTaskId() {
        int numIds = testStateList.size();
        stateTaskId = new int[numIds];
        for (int i = 0; i < numIds; i++) {
            stateTaskId[i] = testStateList.get(i).getTaskId();
        }
        return stateTaskId;
    }

    public void prepareDummyData() throws Exception {
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
    }

    public Task getTestTask(Task.TASK_TYPE type) {
        if (type.equals(Task.TASK_TYPE.FLOATING)) {
            return dummy_floatingTask;
        } else if (type.equals(Task.TASK_TYPE.DEADLINE)) {
            return dummy_deadlineTask;
        } else {
            return dummy_timedTask;
        }
    }
    /*** Test Cases ***/

    /**
     * Returns a Command String specified by the input parameters that will
     * represent a valid user input to PaddleTask
     * 
     * @param runningIndex
     *            Index of the Task to edit
     * @param desc
     *            New description of the edited Task
     * @param end_date
     *            New end date of the edited Task
     * @param end_time
     *            New end time of the edited Task
     * @param start_date
     *            New start date of the edited Task
     * @param start_time
     *            New start time of the edited Task
     * @param remind
     *            New reminder of the edited Task (both date and time)
     * @return The Command String that will be used as dummy user input
     */
    public String getTestCommand(int runningIndex, String desc, String end_date, String end_time, String start_date,
            String start_time, String remind) {
        String start = TEST_KEYWORD_EMPTY;
        String end = TEST_KEYWORD_EMPTY;

        if (end_date != TEST_KEYWORD_EMPTY || end_time != TEST_KEYWORD_EMPTY) {
            end += TEST_KEYWORD_END;
        }
        if (start_date != TEST_KEYWORD_EMPTY || start_time != TEST_KEYWORD_EMPTY) {
            start += TEST_KEYWORD_START;
        }

        if (desc != TEST_KEYWORD_EMPTY) {
            desc = TEST_KEYWORD_DESC + desc;
        }
        if (end_date != TEST_KEYWORD_EMPTY) {
            end += end_date;
        }
        if (end_time != TEST_KEYWORD_EMPTY) {
            end += end_time;
        }
        if (start_date != TEST_KEYWORD_EMPTY) {
            start += start_date;
        }
        if (start_time != TEST_KEYWORD_EMPTY) {
            start += start_time;
        }
        if (remind != TEST_KEYWORD_EMPTY) {
            remind = TEST_KEYWORD_REMIND + remind;
        }
        return String.format(TEST_COMMAND, runningIndex, desc, end, start, remind);
    }

    // Test errthing
    @Test
    public void test() throws Exception {
        // Test Floating
        testEditTaskCommand(TEST_TASKTYPE_FLOATING, TEST_EDIT_FLOATING_DESCRIPTION, TEST_SAMPLE_FLOAT_ID,
                getTestCommand(TEST_SAMPLE_FLOAT_ID, // Running index of sample
                                                     // Floating Task
                        TEST_SAMPLE_DESCRIPTION, // Sample description for
                                                 // edited Task
                        TEST_KEYWORD_EMPTY, // End date
                        TEST_KEYWORD_EMPTY, // End time
                        TEST_KEYWORD_EMPTY, // Start date
                        TEST_KEYWORD_EMPTY, // Start time
                        TEST_KEYWORD_EMPTY), // Reminder date and time
                TEST_SAMPLE_DESCRIPTION, null, null, null);

        testEditTaskCommand(TEST_TASKTYPE_DEADLINE, TEST_ADD_END_DATE_TO_FLOATING, TEST_SAMPLE_FLOAT_ID,
                getTestCommand(TEST_SAMPLE_FLOAT_ID, // Running index of sample
                                                     // Floating Task
                        TEST_SAMPLE_DESCRIPTION, // Sample description for
                                                 // edited Task
                        TEST_SAMPLE_END_DATE, // End date
                        TEST_KEYWORD_EMPTY, // End time
                        TEST_KEYWORD_EMPTY, // Start date
                        TEST_KEYWORD_EMPTY, // Start time
                        TEST_KEYWORD_EMPTY), // Reminder date and time
                TEST_SAMPLE_DESCRIPTION, getExpectedEnd(TEST_SAMPLE_END_DATE, null), null, null);

        testEditTaskCommand(TEST_TASKTYPE_DEADLINE, TEST_ADD_END_DATE_AND_REMINDER_TO_FLOATING, TEST_SAMPLE_FLOAT_ID,
                getTestCommand(TEST_SAMPLE_FLOAT_ID, // Running index of sample
                                                     // Floating Task
                        TEST_SAMPLE_DESCRIPTION, // Sample description for
                                                 // edited Task
                        TEST_SAMPLE_END_DATE, // End date
                        TEST_KEYWORD_EMPTY, // End time
                        TEST_KEYWORD_EMPTY, // Start date
                        TEST_KEYWORD_EMPTY, // Start time
                        TEST_KEYWORD_EMPTY), // Reminder date and time
                TEST_SAMPLE_DESCRIPTION, getExpectedEnd(TEST_SAMPLE_END_DATE, null), null, null);

        testEditTaskCommand(TEST_TASKTYPE_DEADLINE, TEST_ADD_END_DATE_TO_FLOATING, TEST_SAMPLE_FLOAT_ID,
                getTestCommand(TEST_SAMPLE_FLOAT_ID, // Running index of sample
                                                     // Floating Task
                        TEST_SAMPLE_DESCRIPTION, // Sample description for
                                                 // edited Task
                        TEST_SAMPLE_END_DATE, // End date
                        TEST_KEYWORD_EMPTY, // End time
                        TEST_KEYWORD_EMPTY, // Start date
                        TEST_KEYWORD_EMPTY, // Start time
                        TEST_KEYWORD_EMPTY), // Reminder date and time
                TEST_SAMPLE_DESCRIPTION, getExpectedEnd(TEST_SAMPLE_END_DATE, null), null, null);
                // Test Deadline

        // Test Timed
    }

    /**
     * Executes the command specified by the input userCommand and perform
     * various assert checks to verify expected results (input parameters)
     * against actual results
     * 
     * @param expectedTaskType
     *            Expected Task type (FLOATING,DEADLINE,TIMED)
     * @param testDescription
     *            Description of this test case
     * @param taskId
     *            TaskID of the Task being edited (For retrieving and performing
     *            assert checks)
     * @param userCommand
     *            Sample userinput that will be treated as valid user command
     *            String
     * @param expectedTaskDescription
     *            Expected Task description
     * @param expectedStart
     *            Expected Start (date/time)
     * @param expectedEnd
     *            Expected End (date/time)
     * @param expectedReminder
     *            Expected Reminder (date/time)
     * @throws Exception
     */
    public void testEditTaskCommand(Task.TASK_TYPE expectedTaskType, String testDescription, int taskId,
            String userCommand, String expectedTaskDescription, LocalDateTime expectedEnd, LocalDateTime expectedStart,
            LocalDateTime expectedReminder) throws Exception {
        prepareDummyData();

        // Execute the test command
        dummy_editTaskCommand = (EditTaskCommand) commandParserInstance.parse(userCommand, initStateTaskId());
        dummy_editTaskCommand.execute();

        // Get the task of the modified task and retrieve the TASK_TYPE to check
        // what kind of check should be done
        dummy_genericTask = TaskController.getInstance().getTask(taskId);
        Task.TASK_TYPE type = dummy_genericTask.getType();

        switch (type) {
        case FLOATING:
            dummy_floatingTask = (FloatingTask) dummy_genericTask;
            if (expectedTaskType != null) {
                testTaskType(testDescription, expectedTaskType, type);
            }
            if (expectedTaskDescription != null) {
                testTaskDescription(testDescription, expectedTaskDescription, dummy_floatingTask.getDescription());
            }
            break;
        case DEADLINE:
            dummy_deadlineTask = (DeadlineTask) dummy_genericTask;
            if (expectedTaskType != null) {
                testTaskType(testDescription, expectedTaskType, type);
            }
            if (expectedTaskDescription != null) {
                testTaskDescription(testDescription, expectedTaskDescription, dummy_deadlineTask.getDescription());
            }
            if (expectedEnd != null) {
                testTaskEnd(testDescription, expectedEnd, dummy_deadlineTask.getEnd());
            }
            if (expectedReminder != null) {
                testTaskReminder(testDescription, expectedReminder, dummy_deadlineTask.getReminder());
            }
            break;
        case TIMED:
            dummy_timedTask = (TimedTask) dummy_genericTask;
            if (expectedTaskType != null) {
                testTaskType(testDescription, expectedTaskType, type);
            }
            if (expectedTaskDescription != null) {
                testTaskDescription(testDescription, expectedTaskDescription, dummy_timedTask.getDescription());
            }
            if (expectedStart != null) {
                testTaskStart(testDescription, expectedStart, dummy_timedTask.getStart());
            }
            if (expectedEnd != null) {
                testTaskEnd(testDescription, expectedEnd, dummy_timedTask.getEnd());
            }
            if (expectedReminder != null) {
                testTaskReminder(testDescription, expectedReminder, dummy_timedTask.getReminder());
            }
            break;
        default:
            throw new Exception("Task has invalid type!");
        }
    }

    public LocalDateTime getExpectedEnd(String end_date, String end_time) {
        String end = TEST_KEYWORD_EMPTY;
        if (end_date != null) {
            end += end_date + WHITE_SPACE;
        }
        if (end_time != null) {
            end += end_time;
        }
        return DateTimeHelper.parseStringToDateTime(end);
    }

    public void testTaskType(String testDescription, Task.TASK_TYPE expectedTaskType, Task.TASK_TYPE actualTaskType) {
        assertEquals(testDescription, expectedTaskType, actualTaskType);
    }

    public void testTaskDescription(String testDescription, String expectedDescription, String actualDescription) {
        assertEquals(testDescription, expectedDescription, actualDescription);
    }

    public void testTaskStart(String testDescription, LocalDateTime expectedStart, LocalDateTime actualStart) {
        String expectedStartDate = DateTimeHelper.getDate(expectedStart);
        String expectedStartTime = DateTimeHelper.getTime(expectedStart);
        String actualStartDate = DateTimeHelper.getDate(actualStart);
        String actualStartTime = DateTimeHelper.getTime(actualStart);
        assertEquals(testDescription, expectedStartDate, actualStartDate);
        assertEquals(testDescription, expectedStartTime, actualStartTime);
    }

    public void testTaskEnd(String testDescription, LocalDateTime expectedEnd, LocalDateTime actualEnd) {
        String expectedEndDate = DateTimeHelper.getDate(expectedEnd);
        String expectedEndTime = DateTimeHelper.getTime(expectedEnd);
        String actualEndDate = DateTimeHelper.getDate(actualEnd);
        String actualEndTime = DateTimeHelper.getTime(actualEnd);
        assertEquals(testDescription, expectedEndDate, actualEndDate);
        assertEquals(testDescription, expectedEndTime, actualEndTime);
    }

    public void testTaskReminder(String testDescription, LocalDateTime expectedReminder, LocalDateTime actualReminder) {
        String expectedReminderDate = DateTimeHelper.getDate(expectedReminder);
        String expectedReminderTime = DateTimeHelper.getTime(expectedReminder);
        String actualReminderDate = DateTimeHelper.getDate(actualReminder);
        String actualReminderTime = DateTimeHelper.getTime(actualReminder);
        assertEquals(testDescription, expectedReminderDate, actualReminderDate);
        assertEquals(testDescription, expectedReminderTime, actualReminderTime);
    }

    /*
     * @Test public void editFloatingDescription() throws Exception {
     * prepareDummyData();
     * 
     * // Initialize dummy user command and description that will be used for
     * testing String testDescription = "Testing Floating Description Change!";
     * dummy_userCommand = "edit 1 desc " + testDescription; dummy_floatingTask
     * = (FloatingTask) taskControllerInstance.getTask(1);
     * 
     * // Verify that original task description is not the one that will be used
     * for testing assertNotEquals(
     * "test editFloatingDescription: initial description not equals the one used for testing"
     * , testDescription,dummy_floatingTask.getDescription());
     * 
     * // Execute edit command dummy_editTaskCommand =
     * (EditTaskCommand)commandParserInstance.parse(dummy_userCommand,
     * initStateTaskId()); dummy_editTaskCommand.execute();
     * 
     * // Verify if task description has been correctly set dummy_floatingTask =
     * (FloatingTask) taskControllerInstance.getTask(1); assertEquals(
     * "test editFloatingDescription: new description set", testDescription,
     * dummy_floatingTask.getDescription()); }
     * 
     * @Test public void addEndTimeToFloating() throws Exception {
     * prepareDummyData();
     * 
     * // Build my End with default date and custom time String defaultDate =
     * DateTimeHelper.getDate(DateTimeHelper.now()); String testTime = "11:11";
     * dummy_userCommand = "edit 1 end " + testTime;
     * 
     * // Verify that task to edit is still Floating if casting is successful
     * dummy_floatingTask = (FloatingTask) taskControllerInstance.getTask(1);
     * 
     * //Execute command dummy_editTaskCommand = (EditTaskCommand)
     * commandParserInstance.parse(dummy_userCommand,initStateTaskId());
     * dummy_editTaskCommand.execute();
     * 
     * // Verify become Deadline dummy_genericTask =
     * taskControllerInstance.getTask(1); assertEquals(
     * "test addEndTimeToFloating: verify new task is deadline",
     * dummy_genericTask.getType(), Task.TASK_TYPE.DEADLINE);
     * 
     * // Verify new End is the expected End dummy_deadlineTask = (DeadlineTask)
     * dummy_genericTask; LocalDateTime editedEnd = dummy_deadlineTask.getEnd();
     * 
     * // Verify new End Date is given default value of now() date String
     * editedEndDate = DateTimeHelper.getDate(editedEnd); assertEquals(
     * "test addEndTimeToFloating: verify edited task end date default to today's date"
     * , defaultDate,editedEndDate);
     * 
     * // Verify new End Time is given user specified value String editedEndTime
     * = DateTimeHelper.getTime(editedEnd); assertEquals(
     * "test addEndTimeToFloating: verify edited task end time", testTime,
     * editedEndTime); }
     * 
     * @Test public void addEndDateToFloating() throws Exception {
     * prepareDummyData();
     * 
     * // Build my End with custom date and default time String testDate =
     * DateTimeHelper.getDate(DateTimeHelper.now()); String defaultTime =
     * "00:00"; dummy_userCommand = "edit 1 end " + testDate;
     * 
     * // Verify that task to edit is still Floating if casting is successful
     * dummy_floatingTask = (FloatingTask)taskControllerInstance.getTask(1);
     * 
     * //Execute command dummy_editTaskCommand = (EditTaskCommand)
     * commandParserInstance.parse(dummy_userCommand,initStateTaskId());
     * dummy_editTaskCommand.execute();
     * 
     * // Verify become Deadline dummy_genericTask =
     * taskControllerInstance.getTask(1); assertEquals(
     * "test addEndDateToFloating: verify new task is deadline",
     * dummy_genericTask.getType(), Task.TASK_TYPE.DEADLINE);
     * 
     * // Verify new End Date is given user specified date dummy_deadlineTask =
     * (DeadlineTask) dummy_genericTask; String editedEndDate =
     * DateTimeHelper.getDate(dummy_deadlineTask.getEnd()); assertEquals(
     * "test addEndDateToFloating: verify edited task end date", testDate,
     * editedEndDate);
     * 
     * // Verify new End Time is given default time of 00:00 String
     * editedEndTime = DateTimeHelper.getTime(dummy_deadlineTask.getEnd());
     * assertEquals(
     * "test addEndDateToFloating: verify edited task end time default to 00:00"
     * , defaultTime, editedEndTime); }
     * 
     * @Test public void addEndDateAndTimeToFloating() throws Exception {
     * prepareDummyData();
     * 
     * // Build my End with custom date and time String testDateTime =
     * "01/01/2015 12:34"; dummy_userCommand = "edit 1 end " + testDateTime;
     * 
     * // Verify that task to edit is still Floating if casting is successful
     * dummy_floatingTask = (FloatingTask)taskControllerInstance.getTask(0);
     * 
     * //Execute command dummy_editTaskCommand = (EditTaskCommand)
     * commandParserInstance.parse(dummy_userCommand);
     * dummy_editTaskCommand.execute();
     * 
     * // Verify become Deadline dummy_genericTask =
     * taskControllerInstance.getTask(1); assertEquals(
     * "test addEndDateAndTimeToFloating: verify new task is deadline",
     * dummy_genericTask.getType(), Task.TASK_TYPE.DEADLINE);
     * 
     * // Verify new End is the expected End dummy_deadlineTask = (DeadlineTask)
     * dummy_genericTask; String editedEnd =
     * DateTimeHelper.parseDateTimeToString(dummy_deadlineTask.getEnd());
     * assertEquals(
     * "test addEndDateAndTimeToFloating: verify edited task end date and time",
     * testDateTime, editedEnd); }
     * 
     * @Test public void addStartAndEndToFloating() throws Exception {
     * prepareDummyData();
     * 
     * // Build my Start and End with custom date and time String testStart =
     * "01/01/2015 10:00"; String testEnd = "01/02/2015 23:59";
     * dummy_userCommand = "edit 1 start " + testStart + " end " + testEnd;
     * 
     * // Verify that task to edit is still Floating if casting is successful
     * dummy_floatingTask = (FloatingTask)taskControllerInstance.getTask(0);
     * 
     * //Execute command dummy_editTaskCommand = (EditTaskCommand)
     * commandParserInstance.parse(dummy_userCommand);
     * dummy_editTaskCommand.execute();
     * 
     * // Verify become Timed dummy_genericTask =
     * taskControllerInstance.getTask(1); assertEquals(
     * "test addStartAndEndToFloating: verify new task is Timed",
     * dummy_genericTask.getType(), Task.TASK_TYPE.TIMED);
     * 
     * // Verify new Start and End is the expected Start and End dummy_timedTask
     * = (TimedTask) dummy_genericTask; String editedStart =
     * DateTimeHelper.parseDateTimeToString(dummy_timedTask.getStart()); String
     * editedEnd =
     * DateTimeHelper.parseDateTimeToString(dummy_timedTask.getEnd());
     * assertEquals("test addStartAndEndToFloating: verify edited task start",
     * testStart, editedStart); assertEquals(
     * "test addStartAndEndToFloating: verify edited task end", testEnd,
     * editedEnd); }
     * 
     * 
     * @Test public void editDeadlineDescription() throws Exception {
     * prepareDummyData();
     * 
     * // Initialize dummy user command and description that will be used for
     * testing String testDescription = "Testing Deadline Description Change!";
     * dummy_userCommand = "edit 2 desc " + testDescription; dummy_deadlineTask
     * = (DeadlineTask) taskControllerInstance.getTask(2);
     * 
     * // Verify that original task description is not the one that will be used
     * for testing assertNotEquals(
     * "test editDeadlineDescription: initial description not equals the one used for testing"
     * , testDescription,dummy_deadlineTask.getDescription());
     * 
     * // Execute edit command dummy_editTaskCommand = (EditTaskCommand)
     * commandParserInstance.parse(dummy_userCommand);
     * dummy_editTaskCommand.execute();
     * 
     * // Verify if task description has been correctly set dummy_deadlineTask =
     * (DeadlineTask) taskControllerInstance.getTask(2); assertEquals(
     * "test editDeadlineDescription: new description set", testDescription,
     * dummy_deadlineTask.getDescription()); }
     * 
     * @Test public void editDeadlineEndTime() {
     * 
     * }
     * 
     * @Test public void editDeadlineEndDate() {
     * 
     * }
     * 
     * @Test public void editDeadlineEndDateTime() {
     * 
     * }
     * 
     * @Test public void editDeadlineDescriptionAndEnd() {
     * 
     * }
     * 
     * @Test public void addStartToDeadline() {
     * 
     * }
     * 
     * @Test public void addStartAndEndToDeadline() {
     * 
     * }
     * 
     * // Reminder related test case for DeadlineTask
     * 
     * @Test public void editTimedDescription() {
     * 
     * }
     * 
     * @Test public void editTimedStart() {
     * 
     * }
     * 
     * @Test public void editTimedEnd() {
     * 
     * }
     * 
     * @Test public void editTimedCompleteStatus() {
     * 
     * }
     * 
     * @Test public void editTimedDescriptionAndStart() {
     * 
     * }
     * 
     * @Test public void editTimedDescriptionAndStartAndEnd() {
     * 
     * }
     * 
     * @Test public void editTimedDescriptionAndStartAndEndAndCompleteStatus() {
     * 
     * }
     */
}
```
