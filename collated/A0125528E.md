# A0125528E
###### src\main\paddletask\command\api\HelpCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;

import main.paddletask.common.data.HelpManual;
import main.paddletask.task.entity.Task;

public class HelpCommand extends Command{
	
	/*** Variables ***/
	private static final String KEYWORD_HELP = "help";

	private String commandType = "";
	private String helpComments = "";

	/*** Methods ***/
	/**
	 * This method is to execute the help command.
	 * It retrieves the necessary help statements from
	 * the option of the help command executed.
	 * UI:MainFrame observer will be notified 
	 * to display the necessary outputs.
	 * 
	 * @return taskList
	 * 				ArrayList of tasks
	 */
	@Override
	public ArrayList<Task> execute() {
		// TODO Auto-generated method stub
		HelpManual manual = HelpManual.getInstance();
		if(hasOption(KEYWORD_HELP)){
			if(getOption(KEYWORD_HELP)==null){
				commandType = "";
			} else{
				commandType = getOption(KEYWORD_HELP).getStringValue();
			}
		} else{
			assert false;
		}
		//System.out.println("commandtype = " + commandType);
		helpComments = manual.getHelp(commandType.trim());
		//System.out.println("help comments = " + helpComments);
		setChanged();
		notifyObservers(helpComments);
		return null;
	}

	/**
	 * This method is to get help comments of this instance
	 * of command.
	 * 
	 * @return helpComments
	 * 				String of help statements
	 */
	public String getHelpComments(){
		return helpComments;
	}

```
###### src\main\paddletask\command\api\MoreCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;

import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.Task;

public class MoreCommand extends Command{
	
	/*** Variables ***/
    private TaskController taskController;
    
	/*** Methods ***/
    
	@Override
	/**
	 * This method is to execute the more command.
	 * It retrieves the attributes of the task selected
	 * and return the task to be displayed.
	 * 
	 * 
	 * @return taskList
	 * 				ArrayList of tasks
	 */
	public ArrayList<Task> execute() throws Exception {
		// TODO Auto-generated method stub
		ArrayList<Task> taskList = new ArrayList<Task>();
		int taskId = getOption("more").getIntegerValue();
		taskController = TaskController.getInstance();
		Task t = taskController.getTask(taskId);
		taskList.add(t);
		return taskList;
	}

```
###### src\main\paddletask\command\api\ViewTaskCommand.java
``` java
package main.paddletask.command.api;

import java.time.LocalDateTime;
import java.util.ArrayList;

import main.paddletask.common.util.DateTimeHelper;
import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.FloatingTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.TimedTask;

public class ViewTaskCommand extends Command {

	/*** Variables ***/
	private static final int OFFSET_ZERO = 0;
	private static final int OFFSET_ONE = 1;
	
	private static final String TYPE_ALL = "all";
	private static final String TYPE_COMPLETE = "complete";
	private static final String PERIOD_TODAY = "today";
	private static final String PERIOD_TOMORROW = "tomorrow";
	private static final String PERIOD_WEEK = "week";
	private static final String PERIOD_MONTH = "month";
	private static final String PERIOD_ALL = "all";
	
	
	private String type = null;
	private String period = null;
	
	private TaskController taskController = TaskController.getInstance();

	/*** Methods ***/
    /**
     * This method retrieves an array list of Task based on user's input on filters of the tasks.
     * 
     * 
     * @return Pair
     * 				Array list of task
     * 
     */
	@Override
	public ArrayList<Task> execute() {
		determineTypePeriod();
		ArrayList<Task> taskList = null;
		try{
			taskList = selectTasksByType(taskList);
			taskList = selectTaskByPeriod(taskList);
		}catch(Exception e) { }
		setChanged();
		notifyObservers(null);
		
		return taskList;
	}
	
    /**
     * This method determines the type 
     * and the period from the options 
     * given by the user input.
     * The type and period variable will be set here.
     */
	private void determineTypePeriod() {
		if (hasOption(TYPE_COMPLETE)) {
			this.type = TYPE_COMPLETE;
		} else {
			this.type = TYPE_ALL;
		}
		
		if (hasOption(PERIOD_TODAY)) {
			this.period = PERIOD_TODAY;
		} else if (hasOption(PERIOD_TOMORROW)) {
			this.period = PERIOD_TOMORROW;
		} else if (hasOption(PERIOD_WEEK)) {
			this.period = PERIOD_WEEK;
		} else if (hasOption(PERIOD_MONTH)) {
			this.period = PERIOD_MONTH;
		} else {
			this.period = PERIOD_ALL;
		}
	}

    /**
     * This method selects task types based on variable type from the array list given,
     * and return a list of selected Tasks.
     * 
     * @param ArrayList<Task>
     *            a list of tasks to select from
     * @return Array list of selected tasks
     */
	private ArrayList<Task> selectTasksByType(ArrayList<Task> allTask) throws Exception{
		ArrayList<Task> selectedTask = new ArrayList<Task>();
		if(type.equals(TYPE_COMPLETE)){
			allTask = taskController.getTask();
			for(Task t : allTask){
				if(t.isComplete()){
					selectedTask.add(t);
				}
			}
		} else {
			allTask = taskController.getTask();
			for(Task t : allTask){
				if(!t.isComplete()){
					selectedTask.add(t);
				}
			}
		}
		return selectedTask;
	}

    /**
     * This method selects task based on variable period from the array list given,
     * and return a list of selected Tasks.
     * All tasks with deadline before the period variable will be returned.
     * 
     * @param allTask
     *            an array list of tasks to select from
     * @return selectedTask
     * 			  an array list of selected tasks
     */
	public ArrayList<Task> selectTaskByPeriod(ArrayList<Task> allTask) throws Exception{
		if (this.period == PERIOD_ALL) {
			return allTask;
		}
		ArrayList<Task> selectedTask = new ArrayList<Task>();
		LocalDateTime beforeThisTime = checkPeriod();
		for(Task t : allTask){
			//LocalDateTime deadline = null;
			if(FloatingTask.class.isInstance(t)){
				selectedTask.add(t);
			}else{
				if(DeadlineTask.class.isInstance(t)){
					LocalDateTime deadline = null;
					DeadlineTask task = (DeadlineTask) t;
					deadline = task.getEnd();
					
					if(deadline.isBefore(beforeThisTime)){
						selectedTask.add(t);
					}
				}else if(TimedTask.class.isInstance(t)){
					LocalDateTime deadline = null;
					TimedTask task = (TimedTask) t;
					deadline = task.getEnd();
					
					if(deadline.isBefore(beforeThisTime)){
						selectedTask.add(t);
					}
				} else{
					assert false : t; //Task should be belong to either floating, deadline or timed. 
				}
			}
		}

		return selectedTask;
	}

    /**
     * This method offset the period into a LocalDateTime object.
     *    
     * @return LocalDateTime offset by period
     */
	public LocalDateTime checkPeriod() {
		LocalDateTime beforeThisTime = DateTimeHelper.now();
		period = period.toLowerCase();
		switch(period){
		case "tomorrow":
			beforeThisTime = beforeThisTime.withHour(OFFSET_ZERO).withMinute(OFFSET_ZERO).withSecond(OFFSET_ZERO)
							.withNano(OFFSET_ZERO).plusDays(OFFSET_ONE).plusDays(OFFSET_ONE);
			break;

		case "week":
			beforeThisTime = beforeThisTime.withHour(OFFSET_ZERO).withMinute(OFFSET_ZERO).withSecond(OFFSET_ZERO)
							.withNano(OFFSET_ZERO).plusDays(OFFSET_ONE).plusWeeks(OFFSET_ONE);
			break;

		case "month":
			beforeThisTime = beforeThisTime.withHour(OFFSET_ZERO).withMinute(OFFSET_ZERO).withSecond(OFFSET_ZERO)
							.withNano(OFFSET_ZERO).plusDays(OFFSET_ONE).plusMonths(OFFSET_ONE);
			break;

		case "today":
			beforeThisTime = beforeThisTime.withHour(OFFSET_ZERO).withMinute(OFFSET_ZERO).withSecond(OFFSET_ZERO)
				.withNano(OFFSET_ZERO).plusDays(OFFSET_ONE);
			break;
		default:
			assert false : period;		//This switch should not have any default;
		}
		return beforeThisTime;
	}

```
###### src\main\paddletask\common\data\HelpManual.java
``` java
package main.paddletask.common.data;

public class HelpManual {
	
	/*** Variables ***/
	private static HelpManual manual = null;
	private static final String OVERALL_MSG = "PADDLETASK HELP MANUAL\n";
	private static final String ADD_MSG ="ADD COMMAND \n"
			+ "This command adds a new task into the system. Tasks' attributes are described as follows.\n"
			+ "add task name - Add new floating task \n"
			+ "\t- Eg. add buy clothing\n"
			+ "add task name [by] date=dd/mm/yyyy time=hh:mm - Add new deadline/timed task \n"
			+ "\t- Eg. add voting by 11/09/2015\n"
			+ "\t- Eg. add voting by 11/09/2015 11:00\n"
			+ "add task name [between] date=dd/mm/yyyy time=hh:mm [and] date=dd/mm/yyyy time=hh:mm - Add new period task\n"
			+ "\t- Eg. add study for exams between 12/09/2015 and 15/09/2015\n"
			+ "\t- Eg. add study for exams between 12/09/2015 11:00 and 15/09/2015 12:00";
	private static final String EDIT_MSG ="EDIT COMMAND \n"
			+ "edit task id [desc | -d] new task name "
			+ "[start | -s] new start date=hh:mm new start time=dd/mm/yyyy "
			+ "[end | -e] new end time=hh:mm new end date=dd/mm/yyyy "
			+ "- Modifies the task name/start date/start time/end date/end time specified by the task id to the new values. "
			+ "In order to get the task id, see the disclaimer under \"viewing tasks\"\n"
			+ "\t- Eg. edit 1 desc eat lunch\n"
			+ "\t- Eg. edit 1 -d eat lunch\n"
			+ "\t- Eg. edit 2 start 12:00 11/09/2015\n"
			+ "\t- Eg. edit 2 -s 12:00 11/09/2015\n"
			+ "\t- Eg. edit 3 end 12/09/2015 14:00\n"
			+ "\t- Eg. edit 3 -e 12/09/2015 14:00\n"
			+ "\t- Eg. edit 4 desc play piano start 12/09/2015 14:00 end 12/09/2015 16:00\n"
			+ "\t- Eg. edit 4 -d play piano -s 12/09/2015 14:00 -e 12/09/2015 16:00\n"
			+ "\t- Eg. edit 5 end 18:00\n"
			+ "\t- Eg. edit 5 -e 18:00";
	private static final String VIEW_MSG ="VIEW COMMAND \n"
			+ "view [all | floating | deadline | timed | complete] [today | tomorrow | week | month]"
			+ "- Display a list of tasks in categories of type and the deadline in the categories of time. \n"
			+ "\t- Eg. view all today\n"
			+ "\t- Eg. view deadline\n"
			+ "\t- Eg. view week\n"
			+ "\t- Eg. view complete";
	private static final String DELETE_MSG ="DELETE COMMAND \n"
			+ "delete task id/s... - Deletes the task as specified by the task id permanently. "
			+ "All related information will be deleted as well. You can choose to enter one or more tasks.\n"
			+ "\t- Eg. delete 1\n"
			+ "\t- Eg. delete 1 2\n"
			+ "delete [between] date=dd/mm/yyyy time=hh:mm [and] date=dd/mm/yyyy time=hh:mm - "
			+ "Deletes all tasks that falls between the period specified.\n"
			+ "\t- Eg. delete between 12/09/2015 16:00 and 15/09/2015 17:00";
	private static final String COMPLETE_MSG ="COMPLETE COMMAND \n"
			+ "complete task id/s - Mark the task as specified by the task id as completed, "
			+ "so that any reminders will be turned off. You can choose to enter one or more tasks. \n"
			+ "\t- Eg. complete 1"
			+ "\t- Eg. complete 1 2";
	private static final String SEARCH_MSG ="SEARCH COMMAND\n"
			+ "search | /s search sequence/dates \n"
			+ "Searches the whole Task list for Tasks that has description or dates that matches the search sequence or search dates.\n"
			+ "Multiple search sequence/dates are allowed. \n"
			+ "\t- Eg. search assignments \n"
			+ "\t- Eg. search assignments 12/12/2015\n"
			+ "\t- Eg. search assignments quizzes\n"
			+ "\t- Eg. search 12/12/2015 13/12/2015";

	private static final String UNDO_MSG ="UNDO COMMAND\n"
			+ "undo - To undo a previous operation that modifies the data file, such as setdirectory, \n"
			+ "add, edit, delete and complete, type undo. This will undo the effects of the previous operations.";
	private static final String REDO_MSG ="REDO COMMAND\n"
			+ "redo - To redo a previous undo, an undo command have to be done previously. \n"
			+ "If there is no undo command performed, this redo command will fail.";
	private static final String EXIT_MSG ="EXIT COMMAND \n"
			+ "exit - Close and exit PaddleTask";
	private static final String CLEAR_MSG ="CLEAR COMMAND \n"
			+ "clear - Clears output area of PaddleTask";
	private static final String HELP_MSG ="HELP COMMAND \n"
			+ "help command - Display help message for command. If no command is keyed, all help messages will show.\n"
			+ "\t- Eg. help\n"
			+ "\t- Eg. help add";
	private static final String MORE_MSG = "MORE COMMAND \n"
			+ "More task id - This command will display the selected task in full details for the user. \n"
			+ "\t- Eg. more 1\n"
			+ "\t- Eg. more 2";
	private static final String TAG_MSG = "TAG/UNTAG COMMAND \n"
			+ "To tag or untag an existing task, type tag/untag, followed by the running index of the task and the tags to add/remove.\n"
			+ "You may enter 1 or more tags. Note that the tags have to be preceded with a ‘#’. \n"
			+ "\t- Eg. tag 1 #yolo\n"
			+ "\t- Eg. untag 1 #yolo";
	private static final String SET_DIR_MSG = "SET DIRECTORY COMMAND \n"
			+ "set directory command - , you can change the directory of where "
			+ "the data file will be stored instead of using the default location. \n"
			+ "\t- Eg. setdirectory	C:\\Users\\Admin\\Desktop";
			
	private static final String ERROR_MSG = "No such command for Help found";
	private static final String NEXT_LINE = "\n";
	
	/*** Constructor ***/
	private HelpManual(){
	}
	
	/*** Methods ***/
	/**
	 * This method retrieves or create a HelpManual object
	 * and returns it.
	 * 
	 * @return manual
	 *            the singleton object of manual
	 * 
	 */
	public static HelpManual getInstance(){
		if(manual == null){
			manual = new HelpManual();
		}
		return manual;
	}
	
	/**
	 * This method uses the given command
	 * and match it according to everything
	 * in this manual. It will return
	 * the string statement for the help section
	 * of the selected section.
	 * 
	 * @return string
	 *            help section for the section
	 * 
	 */
	public String getHelp(String command) {
		if (command.equals(ParserConstants.COMMANDS.ADD.toString())) {
			return ADD_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.EDIT.toString())) {
			return EDIT_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.VIEW.toString())) {
			return VIEW_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.DELETE.toString())) {
			return DELETE_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.COMPLETE.toString())) {
            return COMPLETE_MSG;
        } else if (command.equals(ParserConstants.COMMANDS.SEARCH.toString())) {
			return SEARCH_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.UNDO.toString())) {
			return UNDO_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.REDO.toString())) {
			return REDO_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.CLEAR.toString())) {
			return CLEAR_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.HELP.toString())) {
			return HELP_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.TAG.toString())|| command.equals(ParserConstants.COMMANDS.UNTAG.toString())) {
			return TAG_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.MORE.toString())) {
			return MORE_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.SETDIRECTORY.toString())) {
			return SET_DIR_MSG;
		} else if (command.equals(ParserConstants.COMMANDS.EXIT.toString())) {
			return EXIT_MSG;
		} else if (command.equals(null)|| command.equals("") || command.equals("all") ) {
			return OVERALL_MSG + NEXT_LINE + ADD_MSG + NEXT_LINE + EDIT_MSG + NEXT_LINE + VIEW_MSG + NEXT_LINE + 
					DELETE_MSG + NEXT_LINE + COMPLETE_MSG + NEXT_LINE + SEARCH_MSG + NEXT_LINE + UNDO_MSG + NEXT_LINE 
					+ REDO_MSG + NEXT_LINE + CLEAR_MSG + NEXT_LINE + HELP_MSG + TAG_MSG +
					MORE_MSG + SET_DIR_MSG + NEXT_LINE + EXIT_MSG;
		} else {
			return ERROR_MSG;
		}

	}

	
	
}
```
###### src\main\paddletask\logic\api\OutputProcessor.java
``` java
package main.paddletask.logic.api;

import java.util.ArrayList;
import java.util.Observer;

import main.paddletask.background.Reminder;
import main.paddletask.common.util.DateTimeHelper;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.TimedTask;

public class OutputProcessor {
	/*** Variables ***/
	private static OutputProcessor instance = null;
	private static LogicController executor;
	private static Observer observer;
	private static Reminder reminder;

	private static final String FORMAT = "%1$-5s  %2$-50s  %3$-14s  %4$-8s  %5$-14s  %6$-8s";
	private static final String CLI_FORMAT = "%1$-3s  %2$-25s  %3$-14s  %4$-8s  %5$-14s  %6$-8s";
	private static final String TAGS_FORMAT = "%s ";
	private static final String TAGS_PADDING = "       %s";
	private static final String PRIORITY_INDICATOR = "*";
	private static final char BOLD_INDICATOR = '@';
	private static final char MSG_INDICATOR = '|';
	private static final String VIEW_HEADER = BOLD_INDICATOR + String.format(FORMAT, "ID", "Description", "Start Date","","Deadline", "");
	private static final String CLI_VIEW_HEADER = BOLD_INDICATOR + String.format(CLI_FORMAT, "ID", "Description", "Start Date","","Deadline", "");
	private static final int OFFSET_ONE = 1;
	private static final int OFFSET_ZERO = 0;
	private static final int DOUBLE = 2;
	private static final String NEXT_LINE = "\n";
	private static final int SINGLE_TASK = 1;
	private static final int PRIORITY_ONE = 1;
	private static final int PRIORITY_TWO = 2;
	private static final int MAX_TAGS_SHOWN_LIMIT = 3;
	private static final int MIN_SIZE = 0;
	private static final int MAX_LENGTH = 50;
	private static final int CLI_MAX_LENGTH = 25;
	private static final int REPLACE_LENGTH = 47;
	private static final String EMPTY_STRING = "";
	private static final String REPLACEMENT_STRING = "...";
	private static final String DESC_STRING = "Description: ";
	private static final String TYPE_STRING = "Task Type: ";
	private static final String PRIORITY_STRING = "Priority: ";
	private static final String SPACE_STRING = " ";
	private static final String START_STRING = "Start: ";
	private static final String DEADLINE_STRING = "Deadline: ";
	private static final String REMINDER_STRING = "Reminder: ";
	private static final String TAG_STRING = "Tags: ";
	private static final String RECURRING_STRING = "Recurring: Every ";
	private static boolean ui_Mode = false;

	/*** Constructor ***/
	private OutputProcessor(){
		executor = LogicController.getInstance(observer);
		executor.addObserver(observer);
		reminder = Reminder.getInstance(observer);
		reminder.addObserver(observer);
	}

	/*** Methods ***/
	/**
	 * This method returns an instance of the OutputProcessor. 
	 * This is an implementation of Singleton Class.
	 * 
	 * @return instance	
	 * 				OutputProcessor's singleton object
	 */
	public static OutputProcessor getInstance(Observer observer){
		if(instance == null){
			OutputProcessor.observer = observer;
			instance = new OutputProcessor();
		}

		return instance;
	}

	/**
	 * This method returns an array of output from LogicController class.
	 * 
	 * @param input 
	 *            String input string of the user
	 * @return output
	 * 			  String array for output
	 */
	public String[] processUserInput(String input){
		String[] output = null;
		ArrayList<Task> taskList = executor.processCommand(input);

		if(taskList != null){
			if(taskList.size() == SINGLE_TASK){
				output = formatOutput(taskList.get(OFFSET_ZERO));
			}
			else{
				output = formatOutput(taskList);
			}
			output = getSuccessMessage(input, output);
		}
		return output;
	}

	private String[] getSuccessMessage(String input, String[] output) {
		String[] successOutput = new String[output.length + 1];
		successOutput [0] = MSG_INDICATOR + executor.getSuccessfulMessage();
		for (int i = 0; i < output.length; i++) {
			successOutput[i+1] = output[i];
		}
		return successOutput;
	}

	/**
	 * This method formats the variable needed from each task to string
	 * and store them into a string array.
	 * Max characters to be displayed for description is 50.
	 * Anything more will be substring(0,47). 
	 * 
	 * @param taskList 
	 *            Array list of tasks
	 * @return output
	 * 			String array of outputs
	 */
	public String[] formatOutput(ArrayList<Task> taskList){
		String[] output = new String[(taskList.size() * DOUBLE) + OFFSET_ONE];
		int rowNumber = OFFSET_ZERO;
		String format = FORMAT;
		if (!ui_Mode) {
			format = CLI_FORMAT;
			output[rowNumber++] = CLI_VIEW_HEADER;
		} else {
			output[rowNumber++] = VIEW_HEADER;
		}
		for(int i = 0; i < taskList.size();i++){
			Task selectedTask = taskList.get(i);
			String[] taskDetails = selectedTask.toDetailsArray();
			int detailsPointer = OFFSET_ZERO;
			String priorityIndicator = EMPTY_STRING;
			if(selectedTask.getPriority() == PRIORITY_TWO){
				priorityIndicator = PRIORITY_INDICATOR;
			}else if(selectedTask.getPriority() == PRIORITY_ONE){
				priorityIndicator = PRIORITY_INDICATOR + PRIORITY_INDICATOR;
			}
			output[rowNumber++] = priorityIndicator + String.format(format, i+OFFSET_ONE,
								  taskDetails[++detailsPointer].length() > (ui_Mode ? MAX_LENGTH : CLI_MAX_LENGTH) ? 
								  taskDetails[detailsPointer].substring(OFFSET_ZERO, 
										  (ui_Mode ? REPLACE_LENGTH : CLI_MAX_LENGTH - MAX_TAGS_SHOWN_LIMIT)) + 
								  		   REPLACEMENT_STRING : taskDetails[detailsPointer],
								  DateTimeHelper.getDayOfWeek(taskDetails[++detailsPointer]),
								  taskDetails[++detailsPointer],
								  DateTimeHelper.getDayOfWeek(taskDetails[++detailsPointer]),
								  taskDetails[++detailsPointer]);
			ArrayList<String> tags = selectedTask.getTags();
			if(tags!=null){
				if(tags.size()>MIN_SIZE){
					String tag = EMPTY_STRING;
					if(!tags.get(OFFSET_ZERO).equals(EMPTY_STRING)){
						for(int j = 0; j < tags.size(); j++){
							String s = tags.get(j);
							if(!s.equals(EMPTY_STRING)){
								tag+=String.format(TAGS_FORMAT, tags.get(j));
							}
							if(j == MAX_TAGS_SHOWN_LIMIT){
								break;
							}
						}
						output[rowNumber++] = String.format(TAGS_PADDING, tag);
					}
				}
			}
		}
		return output;
	}

	/**
	 * This method formats the variable needed from the selected task to string
	 * and store them into a string array.
	 * 
	 * @param task
	 * 				selected task to display
	 * @return String array
	 */
	public String[] formatOutput(Task task){
		ArrayList<String> output = new ArrayList<String>();
		formatDescription(task, output);
		formatType(task, output);
		formatPriority(task, output);
		formatBaseOnTaskType(task, output);
		formatTags(output, task);
		return output.toArray(new String[output.size()]);
	}
	
	/**
	 * This method formats the descriptions of the given task
	 * and insert into the output array list.
	 * 
	 * @param task
	 * 				selected Task
	 * 		  output
	 *            	Array list of outputs
	 */
	public void formatDescription(Task task, ArrayList<String> output) {
		String line =  DESC_STRING + task.getDescription();
		output.add(line);
	}

	/**
	 * This method formats the task types of the given task
	 * and insert into the output array list.
	 * 
	 * @param task
	 * 				selected Task
	 * 		  output
	 *            	Array list of outputs
	 */
	public void formatType(Task task, ArrayList<String> output) {
		String line;
		line =  TYPE_STRING + task.getType().toString().toLowerCase();
		output.add(line);
	}

	/**
	 * This method formats the priority of the given task
	 * and insert into the output array list.
	 * 
	 * @param task
	 * 				selected Task
	 * 		  output
	 *            	Array list of outputs
	 */
	public void formatPriority(Task task, ArrayList<String> output) {
		String line;
		line =  PRIORITY_STRING + task.getPriority();
		output.add(line);
	}
	
	/**
	 * This method formats the tags of the given task
	 * and insert into the output array list.
	 * 
	 * @param task
	 * 				selected Task
	 * 		  output
	 *            	Array list of outputs
	 */
	public void formatTags(ArrayList<String> output, Task task) {
		ArrayList<String> tags = task.getTags();
		String line;
		if(tags!= null){
			if(tags.size()>MIN_SIZE){
				line = TAG_STRING;
				if(!tags.get(OFFSET_ZERO).equals(EMPTY_STRING) || tags.size()>OFFSET_ONE){
					for(String s : tags){
						line += String.format(TAGS_FORMAT, s);
					}
					output.add(line);
				}
			}
		}
		output.add(NEXT_LINE);
	}

	/**
	 * This method formats the task based on the task type to extract
	 * necessary attributes uniquely to the task types.
	 * 
	 * @param task
	 * 				selected Task
	 * 		  output
	 *            	Array list of outputs
	 */
	public void formatBaseOnTaskType(Task task, ArrayList<String> output) {
		String line;
		if(task instanceof TimedTask){
			TimedTask t = (TimedTask)task;
			line =  START_STRING + DateTimeHelper.getDate(t.getStart()) + SPACE_STRING + DateTimeHelper.getTime(t.getStart());
			output.add(line);
			line =  DEADLINE_STRING + DateTimeHelper.getDate(t.getEnd()) + SPACE_STRING + DateTimeHelper.getTime(t.getEnd());
			output.add(line);
			if(t.getReminder()!=null){
				line = REMINDER_STRING + DateTimeHelper.getDate(t.getReminder()) + SPACE_STRING + DateTimeHelper.getTime(t.getReminder());
				output.add(line);
			}
			if(t.isRecurring()){
				line = RECURRING_STRING + t.getRecurPeriod().toString().toLowerCase();
				output.add(line);
			}
		} else if(task instanceof DeadlineTask){
			DeadlineTask t = (DeadlineTask)task;
			line = DEADLINE_STRING  + DateTimeHelper.getDate(t.getEnd()) + SPACE_STRING + DateTimeHelper.getTime(t.getEnd());
			output.add(line);
			if(t.getReminder()!=null){
				line = REMINDER_STRING + DateTimeHelper.getDate(t.getReminder()) + SPACE_STRING + DateTimeHelper.getTime(t.getReminder());
				output.add(line);
			}
			if(t.isRecurring()){
				line = RECURRING_STRING + t.getRecurPeriod().toString().toLowerCase();
				output.add(line);
			}
		} else {
		}
	}

	/**
	 * This method sets the variable ui_Mode to the given boolean.
	 * 
	 * @param ui_Mode
	 */
	public void setUIModeEnabled(boolean ui_Mode) {
		OutputProcessor.ui_Mode = ui_Mode;
	}


}
```
###### src\main\paddletask\task\entity\DeadlineTask.java
``` java
    /**
     * This method gets the end date
     * in a primitive array
     * 
     * @return       array of information
     */
    public String[] toDetailsArray(){
        String[] details = super.toDetailsArray();
        String endDay = DateTimeHelper.getDayOfWeek(DateTimeHelper.getDate(_end)).substring(0, 3);
        details[4] = endDay + " " + DateTimeHelper.getDate(_end);
        details[5] = DateTimeHelper.getTime(_end);
        return details;
    }
}
```
###### src\main\paddletask\task\entity\Task.java
``` java
    /**
     * This method gets the taskId, type and description
     * in a primitive array
     * 
     * @return      array of information
     */
    public String[] toDetailsArray(){
        int counter = 0;
        _details[counter] = _taskId + "";
        _details[++counter] = _description;
        return _details;
    }
}
```
###### src\main\paddletask\task\entity\TimedTask.java
``` java
    /**
     * This method gets the start and end date
     * in a primitive array
     * 
     * @return      array of information
     */
    public String[] toDetailsArray(){
        String[] details = super.toDetailsArray();
        String startDay = DateTimeHelper.getDayOfWeek(DateTimeHelper.getDate(_start)).substring(0, 3);
        String endDay = DateTimeHelper.getDayOfWeek(DateTimeHelper.getDate(_end)).substring(0, 3);
        details[2] = startDay + " " + DateTimeHelper.getDate(_start);
        details[3] = DateTimeHelper.getTime(_start);
        details[4] = endDay + " " + DateTimeHelper.getDate(_end);
        details[5] = DateTimeHelper.getTime(_end); 
        
        return details;
    }
}
```
###### src\main\paddletask\ui\controller\UIController.java
``` java
package main.paddletask.ui.controller;

import java.util.ArrayList;
import java.util.Observer;

import main.paddletask.logic.api.OutputProcessor;
import main.paddletask.task.entity.Task;

public class UIController {

	/*** Variables ***/
	private static UIController instance = null;
	private static Observer observer;
	private static OutputProcessor outputProcessor = null;

	/*** Constructor ***/
	private UIController(){
		outputProcessor = OutputProcessor.getInstance(observer);
	}

	/*** Methods ***/
	/**
	 * This method returns an instance of the UIController. 
	 * This is an implementation of Singleton Class.
	 * 
	 * @return String array
	 */
	public static UIController getInstance(Observer observer){
		if(instance == null){
			UIController.observer = observer;
			instance = new UIController();
		}
		
		return instance;
	}
	
	/**
	 * This method returns an array of output from Logic Component, OutputProcessor class.
	 * 
	 * @param String 
	 *            Input string of the user
	 * @return String array
	 */
	public String[] processUserInput(String input){
		String[] output = outputProcessor.processUserInput(input);
		return output;
	}
	/**
	 * This method returns an array of output from Logic Component, OutputProcessor class.
	 * 
	 * @param String 
	 *            Input string of the user
	 * @return String array
	 */
	public String[] format(ArrayList<Task> taskList){
		String[] output = outputProcessor.formatOutput(taskList);
		return output;
	}
	
	/**
	 * This method returns an array of output from Logic Component, OutputProcessor class.
	 * 
	 * @param new_Observer
	 *            Observer class to be used
	 */
	public static void setObserver(Observer new_Observer){
		observer = new_Observer;
	}
	
	/**
	 * This method sets the outputProcessor with the boolean of the ui mode.
	 * 
	 * @param ui_Mode
	 * 			boolean of the ui mode
	 */
	public static void setUIModeEnabled(boolean ui_Mode) {
		outputProcessor.setUIModeEnabled(ui_Mode);
	}
}
```
###### src\main\paddletask\ui\view\CliView.java
``` java
package main.paddletask.ui.view;

import java.util.ArrayList;
import java.util.Scanner;

import main.paddletask.common.util.DateTimeHelper;
import main.paddletask.task.entity.Task;
import main.paddletask.ui.controller.UIController;

public class CliView {

	private static final String WELCOME_MSG_1 = "Welcome to PaddleTask.";
	private static final String WELCOME_MSG_2 = "Today is %s.";
	private static final String WELCOME_MSG_3 = "Your upcoming tasks for today:";
	private static final String FIRST_COMMAND = "view all today";
	private static final String REMINDER_MSG = "Reminder Alert!";
	private static final String EMPTY_STRING = "";
	private static final char PRIORITY_INDICATOR = '*';
	private static final char BOLD_INDICATOR = '@';
	private static final char COLOR_INDICATOR = '|';
	private static final int WELCOME_MSG_SIZE = 3;
	private static final int REMOVE_ONE = 1;
	private static final int CHARACTER_LOCATION = 0;
	private static final int OFFSET_ZERO = 0;
	private static UIController uiController;
	
	private static Scanner sc = new Scanner(System.in);
	
	public CliView(UIController uiController) {
		CliView.uiController = uiController;
		cliMode();
		UIController.setUIModeEnabled(false);
	}
	
	/**
	 * This method is to initiate the command line mode
	 * of PaddleTask. This will take in input from the user
	 * to be processed.
	 * 
	 */
	public void cliMode(){
		prepareWelcome();
		while(sc.hasNext()){
			String command = sc.nextLine();
			String[] output = uiController.processUserInput(command);
			if(output!= null){
				outputToCmd(output);
			}

		}
	}

	/**
	 * This method is process the output and
	 * display it onto the command line.
	 * 
	 * @param output 
	 * 					String array to be displayed
	 * 
	 */
	public void outputToCmd(String[] output){
		System.out.println();
		for(String s : output){
			if(s!=null && !s.equals(EMPTY_STRING)){
				while(s.charAt(CHARACTER_LOCATION) == BOLD_INDICATOR || 
						s.charAt(CHARACTER_LOCATION) == PRIORITY_INDICATOR || 
						s.charAt(CHARACTER_LOCATION) == COLOR_INDICATOR){
					s = s.substring(REMOVE_ONE);
					if(s.equals(EMPTY_STRING)){
						break;
					}
				}
				System.out.println(s);
			}
		}
		System.out.println();
	}

	/**
	 * This method is to prepare the welcome message of 
	 * PaddleTask. It will also send a "view all today"
	 * command that will be used to display user's task today
	 * on initialization of PaddleTask.
	 * 
	 */
	public void prepareWelcome(){
		String today = DateTimeHelper.getDate(DateTimeHelper.now());
		String[] outputs = new String[WELCOME_MSG_SIZE];
		int counter = OFFSET_ZERO;
		outputs[counter++] = WELCOME_MSG_1;
		outputs[counter++] = String.format(WELCOME_MSG_2, today);
		outputs[counter++] = WELCOME_MSG_3;
		String[] output = uiController.processUserInput(FIRST_COMMAND);
		outputToCmd(outputs);
		outputToCmd(output);
	}

	/**
	 * This method is will create Reminder on the command line mode and
	 * display the output of the arraylist of tasks to the Command Prompt.
	 * 
	 * @param taskList
	 * 				arraylist of tasks
	 * 
	 */
	public void createReminder(ArrayList<Task> taskList) {
		String[] output = uiController.format((ArrayList<Task>)taskList);
		System.out.println(REMINDER_MSG);
		outputToCmd(output);
	}
	
	/**
	 * This method is the test driver for PaddleTask.
	 * All tests can use this method to test the usabilty of
	 * the entire architecture.
	 * 
	 *  @param 	userCommand
	 *  			String of a command
	 *  		uiController
	 *  			instance of uiController
	 *  @return output
	 *  			String[] of the output
	 *  
	 */
	public static String[] testDriver(String userCommand, UIController uiController){
		UIController.setUIModeEnabled(false);
		CliView.uiController = uiController;
		String[] output = uiController.processUserInput(userCommand);
		ArrayList<String> filterOutput = new ArrayList<String>();
				for(String s : output){
					if(s!=null){
						while(s.charAt(CHARACTER_LOCATION) == BOLD_INDICATOR || 
								s.charAt(CHARACTER_LOCATION) == PRIORITY_INDICATOR ||
								s.charAt(CHARACTER_LOCATION) == COLOR_INDICATOR){
							s = s.substring(REMOVE_ONE);
						}
						System.out.println(s);
						filterOutput.add(s);
					}
				}
		return filterOutput.toArray(output);
	}
	
	/**
	 * This method is the test driver for PaddleTask.
	 * All tests can use this method to test the usabilty of
	 * the entire architecture.
	 * 
	 *  @param 	userCommands
	 *  			String[] of a command
	 *  		uiController
	 *  			instance of uiController
	 *  @return output
	 *  			String[] of the output
	 *  
	 */
	public static String[] testDriver(String[] userCommands, UIController uiController){
		UIController.setUIModeEnabled(false);
		CliView.uiController = uiController;
		String[] output = new String[0];
		for(String s : userCommands){
			output = uiController.processUserInput(s);
		}
		ArrayList<String> filterOutput = new ArrayList<String>();
				for(String s : output){
					if(s!=null){
						while(s.charAt(CHARACTER_LOCATION) == BOLD_INDICATOR || 
								s.charAt(CHARACTER_LOCATION) == PRIORITY_INDICATOR ||
								s.charAt(CHARACTER_LOCATION) == COLOR_INDICATOR){
							s = s.substring(REMOVE_ONE);
						}
						System.out.println(s);
						filterOutput.add(s);
					}
				}
		return filterOutput.toArray(output);
	}
}
```
###### src\main\paddletask\ui\view\CustomizedDocumentFilter.java
``` java
package main.paddletask.ui.view;

import java.awt.Color;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.JTextPane;
import javax.swing.SwingUtilities;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;
import javax.swing.text.MutableAttributeSet;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;

public final class CustomizedDocumentFilter extends DocumentFilter {
	
	/*** Variables ***/
	private JTextPane textPane = null;
	private StyledDocument styledDocument = null;
	private static final StyleContext styleContext = StyleContext.getDefaultStyleContext();
	private static final AttributeSet redAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.RED);
	private static final AttributeSet darkBlueAttributeSet = changeToAnyRGBColor(0, 76, 153);
	private final String REGEX_TAG = "#\\w{1,}";
	private final String REGEX_START_BOUND = "\\b";
	private static final int REMOVE_TRAILING = 1;
	private static final String CARRIAGE_RETURN = "\r\n";
	private static final String NEXT_LINE = "\n";
	private static final String KEYWORD_DEADLINE = "deadline";
	private static final String[] HEADER_KEYWORDS = {"Description", "Task Type", "Priority", "Start", "Deadline", "Reminder", "Tags", "Recurring"};
	private static final String EMPTY_STRING = "";
	private final Pattern HEADER_PATTERN = buildPattern(HEADER_KEYWORDS, "\\b:|");
	private static final int OFFSET_ONE = 1;
	
	/*** Constructors ***/
	public CustomizedDocumentFilter(JTextPane textPane){
		this.textPane = textPane;
		styledDocument = textPane.getStyledDocument();
	}

	/*** Methods ***/
	@Override
	public void insertString(FilterBypass fb, int offset, String text, AttributeSet attributeSet) throws BadLocationException {
		super.insertString(fb, offset, text, attributeSet);
		handleTextChanged();
	}

	@Override
	public void remove(FilterBypass fb, int offset, int length) throws BadLocationException {
		super.remove(fb, offset, length);
		handleTextChanged();
	}

	@Override
	public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attributeSet) throws BadLocationException {
		super.replace(fb, offset, length, text, attributeSet);
		handleTextChanged();
	}

	/**
	 * This method will handle the text changed on the document.
	 * It will be invoke later and will run as a separate thread.
	 * 
	 */
	private void handleTextChanged(){
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				updateTextStyles();
			}
		});
	}

	/**
	 * This method will change the background of the attribute set to a gradient of gray,
	 * and return the changed set.
	 * 
	 *@param backgroundColor
	 * 				Color for background
	 * 
	 * @return background
	 * 				edited attribute set to the gradient
	 */
	public static SimpleAttributeSet setBackgroundColorForHeader(Color backgroundColor){
        SimpleAttributeSet background = new SimpleAttributeSet();
        StyleConstants.setBackground(background, backgroundColor);
        return background;
	}
	
	/**
	 * This method will build the regex from the given
	 * string output.
	 * 
	 * @param keywords
	 * 				String array of keywords
	 */
	private Pattern buildPattern(String[] keywords, String REGEX_END_BOUND){
		StringBuilder sb = new StringBuilder();
		for (String token : keywords) {
			sb.append(REGEX_START_BOUND); 
			sb.append(token);
			sb.append(REGEX_END_BOUND); 
		}
		if (sb.length() > 0) {
			sb.deleteCharAt(sb.length() - REMOVE_TRAILING);
		}
		Pattern p = Pattern.compile(sb.toString());
		return p;
	}
	
	/**
	 * This method will change the attribute set to orange and bold,
	 * and return the changed set.
	 * 
	 * @return orangeAttributeSet
	 * 				edited attribute set to orange
	 */
	public static AttributeSet changeToOrange(){
		AttributeSet orangeAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.ORANGE);
		orangeAttributeSet = styleContext.addAttribute(orangeAttributeSet, StyleConstants.CharacterConstants.Bold, Boolean.TRUE);
		return orangeAttributeSet;
	}
	
	/**
	 * This method will change the attribute set to white and bold,
	 * and return the changed set.
	 * 
	 * @return whiteAttributeSet
	 * 				edited attribute set to white
	 */
	public static AttributeSet changeToWhite(){
		AttributeSet whiteAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.WHITE);
		whiteAttributeSet = styleContext.addAttribute(whiteAttributeSet, StyleConstants.CharacterConstants.Bold, Boolean.TRUE);
		return whiteAttributeSet;
	}
	
	/**
	 * This method will change the attribute set to red and bold,
	 * and return the changed set.
	 * 
	 * @return redAttributeSet
	 * 				edited attribute set to red
	 */
	public static AttributeSet changeToRed(){
		AttributeSet redAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.RED);
		redAttributeSet = styleContext.addAttribute(redAttributeSet, StyleConstants.CharacterConstants.Bold, Boolean.TRUE);
		return redAttributeSet;
	}
	
	/**
	 * This method will change the attribute set to red and bold,
	 * and return the changed set.
	 * 
	 * @return redAttributeSet
	 * 				edited attribute set to red
	 */
	public static AttributeSet changeToAnyRGBColor(int r, int g, int b){
		AttributeSet colorAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, new Color(r,g,b));
		colorAttributeSet = styleContext.addAttribute(colorAttributeSet, StyleConstants.CharacterConstants.Bold, Boolean.TRUE);
		return colorAttributeSet;
	}
	
	/**
	 * This method will change the attribute set to bold,
	 * and return the changed set.
	 * 
	 * @return attributes
	 * 				SimpleAttributeSet set to bold.
	 */
	public static SimpleAttributeSet setBold(){
		SimpleAttributeSet attributes = new SimpleAttributeSet(); 
		attributes.addAttribute(StyleConstants.CharacterConstants.Bold, Boolean.TRUE);
		return attributes;
	}
	
	/**
	 * This method updates the text styles by 
	 * calling changeFontForTags() method.
	 * 
	 */
	private void updateTextStyles(){
		changeFontForTags();
		boldAttributeHeadersForSingleTaskDisplay();
	}
	
	/**
	 * This method prepares an attribute set for blue color.
	 * It will compile a regex for tag to build and find 
	 * all the tags in the document.
	 * This method will then change the tags to blue color and
	 * bold.
	 * 
	 */
	private void changeFontForTags(){
		AttributeSet blueAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.BLUE);
		blueAttributeSet = styleContext.addAttribute(blueAttributeSet, StyleConstants.CharacterConstants.Bold, Boolean.TRUE);
		Pattern pattern = Pattern.compile(REGEX_TAG);
		String text = textPane.getText().replaceAll(CARRIAGE_RETURN ,NEXT_LINE);
		Matcher matcher = pattern.matcher(text);
		while (matcher.find()) {
			// Change the color of recognized tokens
			int start = matcher.start();
			int end = matcher.end();
			styledDocument.setCharacterAttributes(start, end - start, blueAttributeSet, false);
		}
	}
	
	/**
	 * This method will compile a regex for the keywords to build and find 
	 * all the keywords in the document.
	 * This method will then change the keywords to red color.
	 * 
	 */
	@SuppressWarnings("unused")
	private void changeFontOfLineByKeywords(){
		String[] keywords = {KEYWORD_DEADLINE};
		Pattern pattern = buildPattern(keywords, EMPTY_STRING);
		String text = textPane.getText().replaceAll(CARRIAGE_RETURN,NEXT_LINE);

		Matcher matcher = pattern.matcher(text);
		while (matcher.find()) {
			int start = matcher.start();
			String beforeText = text.substring(0, start);
			int startOfLine = beforeText.lastIndexOf(NEXT_LINE);
			String afterText = text.substring(++startOfLine, text.length());
			int endOfLine = afterText.indexOf(NEXT_LINE);
			styledDocument.setCharacterAttributes(startOfLine, endOfLine, redAttributeSet, false);
		}
	}
	
	/**
	 * This method will take in integer value which will allow
	 * modification and increasing/decreasing of the font size of the display.
	 * 
	 * @param change
	 * 				integer value of change
	 */
	public static void changeFontSize(int change, JTextPane textPane){
	    MutableAttributeSet attrs = textPane.getInputAttributes();
	    int size = StyleConstants.getFontSize(attrs);
	    StyleConstants.setFontSize(attrs, size + change);
	    StyledDocument styledDocument = textPane.getStyledDocument();
	    styledDocument.setCharacterAttributes(0, styledDocument.getLength() + OFFSET_ONE, attrs, false);
	}
	
	/**
	 * This method will enhance attributes headers for single task display.
	 * It will build a regex with the pattern of headers, and search for the 
	 * headers to bold and color it to dark blue.
	 * 
	 */
	public void boldAttributeHeadersForSingleTaskDisplay(){
		String text = textPane.getText().replaceAll(CARRIAGE_RETURN,NEXT_LINE);
		Matcher matcher = HEADER_PATTERN.matcher(text);
		while (matcher.find()) {
			int start = matcher.start();
			int end = matcher.end();
			styledDocument.setCharacterAttributes(start, end - start, darkBlueAttributeSet, false);
		}
	}

	public static AttributeSet changeToGreen() {
		AttributeSet orangeAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.GREEN);
		orangeAttributeSet = styleContext.addAttribute(orangeAttributeSet, StyleConstants.CharacterConstants.Bold, Boolean.TRUE);
		return orangeAttributeSet;
	}
}
```
###### src\main\paddletask\ui\view\MainFrame.java
``` java
package main.paddletask.ui.view;

import java.awt.*;
import java.awt.event.*;
import java.net.URL;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.*;

import org.jnativehook.GlobalScreen;
import org.jnativehook.keyboard.NativeKeyEvent;
import org.jnativehook.keyboard.NativeKeyListener;

import main.paddletask.background.Reminder;
import main.paddletask.command.api.ClearCommand;
import main.paddletask.command.api.HelpCommand;
import main.paddletask.command.api.SearchTaskCommand;
import main.paddletask.command.api.ViewTaskCommand;
import main.paddletask.common.util.LoggingHandler;
import main.paddletask.task.entity.Task;
import main.paddletask.ui.controller.UIController;

/**
 * This create the GUI and show it. This is the Mainframe class
 * to hold the panel and the GUI that will be displayed.
 * If CLI mode were to be enabled, this class will be 
 * responsible for getting user input and displaying onto
 * the command line.
 */

public class MainFrame implements Observer{

	/*** Variables ***/
	private static final String TITLE = "PaddleTask";
	private static JFrame frame;
	private static MainPanel panel;
	private static boolean isMinimized = false;
	private static final String CLI_COMMAND = "cli";
	private static UIController uiController;
	private static boolean ui_Mode = false;
	private static MainFrame mainFrame = null;
	private static CliView cliView = null;
	private static final String OPTION_MAXIMIZE = "Maximize";
	private static final String OPTION_ICONIFY = "Iconify";
	private static final String OPTION_CLOSE = "Close";
	private static final int SIZE_PROPORTION = 2;
	private static final int MINIMUM_WIDTH = 920;
	private static final int OFFSET_ZERO = 0;

	/*** Constructor ***/
	public MainFrame(){
		uiController = UIController.getInstance(this);
	}

	/*** Methods ***/
	/**
	 * This method is the main method of the program.
	 * 
	 * @param  String[] argument on execution
	 */
	public static void main(String[] args) {
		LoggingHandler handler = new LoggingHandler();
		handler.setupLoggingHandler();
		initiate(args);
	}

	/**
	 * This method is to initiate the mainFrame object and determine
	 * command line mode or GUI mode to be deployed.
	 * 
	 * @param  String[] argument on execution
	 * 
	 * @return true when the method completes
	 */
	public static boolean initiate(String[] args) {
		mainFrame = new MainFrame();
		if(args.length > OFFSET_ZERO){
			String input = args[OFFSET_ZERO];
			if(input.equals(CLI_COMMAND)){
				cliView = new CliView(uiController);
				return true;
			}
		}
		initiateGUI();
		return true;
	}

	/**
	 * This method is to schedule a job for the event-dispatching thread, followed
	 * by creating and showing this application's GUI.
	 * 
	 */
	public static void initiateGUI() {
		ui_Mode = true;
		UIController.setUIModeEnabled(ui_Mode);
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				createAndShowGUI();
				try {
					implementNativeKeyHook();
				} catch (Throwable e) {
					System.exit(1);
				}
			}
		});
	}

	/**
	 * This method prepare the UI for display and decorations.
	 * 
	 */
	private static void createAndShowGUI() {
		try {
			UIManager.setLookAndFeel("com.jtattoo.plaf.texture.TextureLookAndFeel");
		} catch (Exception e) { }
		prepareFrame();
		if (isSystemTrayReady()) {
			isMinimized = false;
			//minimizeToTray();
		}
	}

	/**
	 * This method prepare the Frame to be displayed.
	 * It sets the variable for the frame and uses CommandLinePanel.
	 * The default size of PaddleTask is set
	 * to the halved of the resolution of the user's screen dynamically
	 * to suit all users' screen.
	 */
	public static void prepareFrame() {
		frame = new JFrame(TITLE);
		frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
		frame.addWindowListener(new WindowAdapter() {
			public void windowIconified(WindowEvent e) {
				minimizeToTray();
			}

			public void windowClosing(WindowEvent e) {
				minimizeToTray();
			}
		});
		//removeDefaultButtons(frame);
		panel = new MainPanel(mainFrame);
		panel.populateContentPane(frame.getContentPane());
		Dimension size = frame.getToolkit().getScreenSize();
		size.setSize(MINIMUM_WIDTH, size.height / SIZE_PROPORTION);
		frame.setMinimumSize(size);
		frame.setSize(size);
		frame.setLocationRelativeTo(null);
		frame.setVisible(true);
		panel.triggerCommandSuggestor();
	}

	/**
	 * This method removes the default buttons of minimize, maximise and close
	 * on the frame. 
	 * 
	 *  @param  Component 
	 *  			JFrame frame
	 */
	@SuppressWarnings("unused")
	private static void removeDefaultButtons(Component com){
		if(com instanceof JButton){
			String name = ((JButton) com).getAccessibleContext().getAccessibleName();
			if(name.equals(OPTION_MAXIMIZE)|| name.equals(OPTION_ICONIFY)||
					name.equals(OPTION_CLOSE)){
				com.getParent().remove(com);
			}
		}
		if (com instanceof Container){
			Component[] comps = ((Container)com).getComponents();
			for(int x = 0, y = comps.length; x < y; x++){
				removeDefaultButtons(comps[x]);
			}
		}
	}

	/**
	 * This method returns the frame of the UI.
	 * 
	 *  @return  frame
	 *  			JFrame frame
	 */
	public JFrame getFrame(){
		return frame;
	}
	
	/**
	 * This method is the update method for Observer class
	 * of MainFrame. 
	 * 
	 *  @param 	o
	 *  			Observable that called update
	 *			arg  
	 *  			argument passed with update
	 *  
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void update(Observable o, Object arg) {
		if (o instanceof ClearCommand || o instanceof ViewTaskCommand || o instanceof SearchTaskCommand) {
			if(ui_Mode){
				MainPanel.setPaneToNull();
			} else{
				System.out.println();
				//System.out.println(CLEAR_SCREEN);
			}
		} else if(o instanceof Reminder){
			if(arg instanceof ArrayList<?>){
				if(ui_Mode){
					panel.createReminder((ArrayList<Task>)arg);
				} else{
					cliView.createReminder((ArrayList<Task>)arg);
				}
			}
		} else if(o instanceof HelpCommand){
			String msg = (String)arg;
			if(ui_Mode){
				MainPanel.updatePrint(msg);
			} else{
				System.out.println(msg);
				System.out.println();
			}
		} else {
			String msg = (String)arg;
			if(ui_Mode){
				MainPanel.displayError(msg);
			} else{
				System.out.println(msg);
				System.out.println();
			}
		}
	}
	
	/**
	 * This method is the test driver for PaddleTask.
	 * All tests can use this method to test the usabilty of
	 * the entire architecture.
	 * 
	 *  @param 	userCommand
	 *  			String of a command
	 *  @return output
	 *  			String[] of the output
	 *  
	 */
	public static String[] testDriver(String userCommand){
		mainFrame = new MainFrame();
		String[] output = CliView.testDriver(userCommand, uiController);
		return output;
	}
	
	/**
	 * This method is the test driver for PaddleTask.
	 * All tests can use this method to test the usabilty of
	 * the entire architecture.
	 * 
	 *  @param 	userCommands
	 *  			String[] of a command
	 *  @return output
	 *  			String[] of the output
	 *  
	 */
	public static String[] testDriver(String[] userCommands){
		mainFrame = new MainFrame();
		String[] output = CliView.testDriver(userCommands, uiController);
		return output;
	}
```
###### src\main\paddletask\ui\view\MainPanel.java
``` java
package main.paddletask.ui.view;
import java.awt.*;
import java.awt.Dialog.ModalityType;
import java.awt.event.*;
import java.util.ArrayList;

import javax.swing.*;
import javax.swing.text.AbstractDocument;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.SimpleAttributeSet;

import main.paddletask.common.data.DoublyLinkedList;
import main.paddletask.common.data.Node;
import main.paddletask.common.util.DateTimeHelper;
import main.paddletask.task.entity.Task;
import main.paddletask.ui.controller.UIController;

@SuppressWarnings("serial")
public class MainPanel extends JPanel implements KeyListener {

	/*** Variables ***/
	private static final String STRING_EMPTY = "";
	private static final String NEXT_LINE = "\n";
	private static final String WELCOME_MSG_1 = "Welcome to PaddleTask.";
	private static final String WELCOME_MSG_2 = "Today is %s.";
	private static final String WELCOME_MSG_3 = "Your upcoming tasks for today:";
	private static final String MODAL_OPTION = "Modal Dialog";
	private static final String FIRST_COMMAND = "view all today";
	private static final String KEYNAME_FONT_UP = "Font up";
	private static final String KEYNAME_FONT_DOWN = "Font down";
	private static final String KEY_ACTIVATE = "Activate Suggestion";
	private static final int OFFSET_ZERO = 0;
	private static final int SUBSTRING_BEGIN = 1;
	private static final char PRIORITY_INDICATOR = '*';
	private static final char BOLD_INDICATOR = '@';
	private static final char MSG_INDICATOR = '|';
	private static final int INCREASE_FONT_SIZE = 1;
	private static final int DECREASE_FONT_SIZE = -1;
	protected static int NUM_COMPONENTS = 3;
	protected UIController uiController = null;
	private static Font font = new Font("Consolas",Font.PLAIN, 15);
	private JTextField inputField = null;
	//private JTextArea textArea = null;
	private static JTextPane textPane = null;
	public static JDialog reminderDialog = null;
	private static JPanel panel = null;
	private static JPanel errorPanel = null;
	private static JLabel errorLabel = null;
	private static DoublyLinkedList commandList = null;
	private Box box = null;
	private Node node = null;
	private String currentCommand = null;
	private static JScrollPane scrollPane = null;
	private MainFrame mainFrame = null;
	private static final float OPACITY_OF_SUGGESTIONS = 0.9f;
	private CommandSuggestor commandSuggestor = null;
	private static final Color backgroundColor = new Color(200, 200, 200); //Gray color
	private static final int timeDelay = 2000;
	private static final ActionListener time = new ActionListener() {
	    @Override
	    public void actionPerformed(ActionEvent evt) {
	    	errorPanel.setVisible(false);
	    	errorTimer.stop();
	    }
	};
	private static final Timer errorTimer = new Timer(timeDelay, time);


	/*** Constructors ***/
	public MainPanel(MainFrame mainFrame){
		this.mainFrame = mainFrame;
		uiController = UIController.getInstance(mainFrame);
		commandList = new DoublyLinkedList();
	}

	/*** Methods ***/
	/**
	 * This method populate a panel for the frame. 
	 * It prepares various components needed for the panel.
	 * 
	 * @param Container
	 *            Container for the pane to be created on.
	 * 
	 */
	public void populateContentPane(Container contentPane) {
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		panel.setBorder(BorderFactory.createLineBorder(Color.black));

		textPane = prepareJTextPane();

		JTextField inputField = prepareTextField();
		scrollPane = prepareScrollPane(textPane);
		
		errorPanel = prepareErrorPanel();
		
		box = prepareBoxComponent(inputField, scrollPane, errorPanel);

		panel.add(box, BorderLayout.PAGE_END);
		contentPane.add(panel, BorderLayout.CENTER);
		prepareWelcome();
		this.setInputFocus();
	}

	/**
	 * This method prepares the program with a welcome message.
	 * It will also perform a command "view all today" to show today's task.
	 * 
	 */
	public void prepareWelcome(){
		String today = DateTimeHelper.getDate(DateTimeHelper.now());
		String[] outputs = new String[3];
		int counter = 0;
		outputs[counter++] = WELCOME_MSG_1;
		outputs[counter++] = String.format(WELCOME_MSG_2, today);
		outputs[counter++] = WELCOME_MSG_3;
		String[] output = uiController.processUserInput(FIRST_COMMAND);
		append(outputs);
		append(output);
	}

	/**
	 * This method prepares a box component to be created on the panel.
	 * Aligns the component together in a box layout vertically.
	 * 
	 * @param JTextField
	 *            the input field on the panel
	 *        JScrollPane
	 * 			  the scroll pane for the text area.		
	 * @return Box format with the components on the panel
	 */
	public Box prepareBoxComponent(JTextField inputField, JScrollPane areaScrollPane, JPanel errorPanel) {
		Box box = Box.createVerticalBox();
		box.add(areaScrollPane);
		box.add(errorPanel);
		box.add(inputField);
		return box;
	}

	/**
	 * This method prepares a scroll pane for the textPane to enable scrolling
	 * for display.
	 * 
	 * @param textPane
	 * 				JTextPane of the panel

	 * @return areaScrollPane 
	 * 				JScrollPane with textPane
	 */
	private JScrollPane prepareScrollPane(JTextPane textPane) {
		final JScrollPane areaScrollPane = new JScrollPane(textPane);
		areaScrollPane.addMouseListener(new MouseListener() {

			@Override
			public void mouseClicked(MouseEvent arg0) {
				inputField.requestFocus();
			}

			@Override
			public void mouseEntered(MouseEvent e) {}

			@Override
			public void mouseExited(MouseEvent e) {}

			@Override
			public void mousePressed(MouseEvent e) {}

			@Override
			public void mouseReleased(MouseEvent e) {}
		});
		textPane.addMouseListener(areaScrollPane.getMouseListeners()[0]);
		areaScrollPane.setVerticalScrollBarPolicy(
				JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		areaScrollPane.setAutoscrolls(true);
		return areaScrollPane;
	}

	/**
	 * This method prepares a textfield for the user to input data.
	 * This will initiate UIController.java upon execution of a input by the user.
	 * 
	 * @return inputField - the JTextField created
	 */
	private JTextField prepareTextField() {
		inputField = new JTextField();
		inputField.setMaximumSize(new Dimension(inputField.getMaximumSize().width ,inputField.getPreferredSize().height));
		inputField.requestFocus();
		inputField.addKeyListener(this);
		inputField.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				String input = inputField.getText();
				addCommandToList(input);
				performCommand(input);
				inputField.setText(STRING_EMPTY);
				currentCommand = null;
			}
		});
		inputField.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke(KeyEvent.VK_F3, 0, true), KEYNAME_FONT_UP);
		inputField.getActionMap().put(KEYNAME_FONT_UP, new AbstractAction() {
			@Override
			public void actionPerformed(ActionEvent ae) {//focuses the first label on popwindow
				CustomizedDocumentFilter.changeFontSize(INCREASE_FONT_SIZE, textPane);
			}
		});
		inputField.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, 0, true), KEYNAME_FONT_DOWN);
		inputField.getActionMap().put(KEYNAME_FONT_DOWN, new AbstractAction() {
			@Override
			public void actionPerformed(ActionEvent ae) {//focuses the first label on popwindow
				CustomizedDocumentFilter.changeFontSize(DECREASE_FONT_SIZE, textPane);
			}
		});
		inputField.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke(KeyEvent.VK_F1, 0, true), KEY_ACTIVATE);
		inputField.getActionMap().put(KEY_ACTIVATE, new AbstractAction() {
			@Override
			public void actionPerformed(ActionEvent ae) {//focuses the first label on popwindow
				commandSuggestor.toggleActivation();
			}
		});
		commandSuggestor = new CommandSuggestor(inputField, mainFrame.getFrame(),
				Color.WHITE.brighter(), Color.BLUE, Color.RED, OPACITY_OF_SUGGESTIONS);
		
		return inputField;
	}
	
	/**
	 * This method prepares a Panel for displaying of error messages to the user.
	 * 
	 * @return errorPanel - the JPanel created
	 */
	private JPanel prepareErrorPanel() {
		errorPanel = new JPanel();
		errorPanel.setMaximumSize(inputField.getMaximumSize());
		errorPanel.setVisible(false);
		errorPanel.setForeground(Color.RED);
		errorPanel.setBackground(Color.WHITE);
		errorPanel.setBorder(BorderFactory.createLineBorder(Color.RED));
		errorPanel.setLayout(new FlowLayout(FlowLayout.LEFT));
		errorPanel.add(prepareErrorLabel());
		return errorPanel;
	}
	

	/**
	 * This method prepares a label for displaying of error messages to the user.
	 * 
	 * @return errorLabel - the JLabel created
	 */
	private JLabel prepareErrorLabel() {
		errorLabel = new JLabel();
		errorLabel.setMaximumSize(inputField.getMaximumSize());
		errorLabel.setHorizontalAlignment(SwingConstants.LEFT);
		errorLabel.setForeground(Color.RED);
		return errorLabel;
	}

	private void addCommandToList(String input){
		node = null;
		commandList.insertLast(input);
	}

	/**
	 * This method appends a string of text into the textPane to display to the user
	 * 
	 * @param s
	 *        	String s to be appended to textPane
	 *        isCommand
	 *        	boolean to check if it is command
	 */
	public static void append(String s, boolean isCommand) {
		try {
			Document doc = textPane.getDocument();
			textPane.setCaretPosition(doc.getLength());
			SimpleAttributeSet color = null;
			if(isCommand){
				color = new SimpleAttributeSet();
				color.addAttributes(CustomizedDocumentFilter.setBold());
			}
			doc.insertString(doc.getLength(), s + NEXT_LINE + NEXT_LINE, color);
		} catch(BadLocationException exc) {
			assert false;
			exc.printStackTrace();
		}

	}

	/**
	 * This method appends a string array of text into the textPane to display to the user
	 * 
	 * @param output
	 * 			String[] to be appended to textPane
	 *        	   
	 */
	public void append(String[] output){
		try {
			Document doc = textPane.getDocument();
			textPane.setCaretPosition(doc.getLength());
			String outputString = STRING_EMPTY;
			for(String s : output ){
				if(s != null){
					outputString = s + NEXT_LINE;
					SimpleAttributeSet color = new SimpleAttributeSet();
					if(outputString.charAt(OFFSET_ZERO)==MSG_INDICATOR){
						color.addAttributes(CustomizedDocumentFilter.setBold());
						color.addAttributes(CustomizedDocumentFilter.changeToGreen());
						outputString = outputString.substring(SUBSTRING_BEGIN);
					}
					if(outputString.charAt(OFFSET_ZERO)==BOLD_INDICATOR){
						color.addAttributes(CustomizedDocumentFilter.setBold());
						outputString = outputString.substring(SUBSTRING_BEGIN);
						color.addAttributes(CustomizedDocumentFilter.setBackgroundColorForHeader(backgroundColor));
					}
					if(outputString.charAt(OFFSET_ZERO)==PRIORITY_INDICATOR){
						color.addAttributes(CustomizedDocumentFilter.changeToOrange());
						outputString = outputString.substring(SUBSTRING_BEGIN);
					}
					if(outputString.charAt(OFFSET_ZERO)==PRIORITY_INDICATOR){
						color.addAttributes(CustomizedDocumentFilter.changeToRed());
						outputString = outputString.substring(SUBSTRING_BEGIN);
					}
					doc.insertString(doc.getLength(), outputString, color);
				}
			}
			doc.insertString(doc.getLength(), NEXT_LINE, null);
		} catch(BadLocationException exc) {
			assert false;
			exc.printStackTrace();
		}
	}

	/**
	 * This method performs the command from the
	 * given string and uses uiController to 
	 * continue the process.
	 * It will prepare to append 
	 * the outputs to be displayed.
	 * 
	 * @return input
	 * 				String input from user
	 */
	public void performCommand(String input){
		boolean isCommand = true;
		String[] output = uiController.processUserInput(input);
		if(output!= null){
			append(input, isCommand);
			append(output);
		}
	}

	/**
	 * This method prepares a text pane for the 
	 * output of the program to be displayed on.
	 * 
	 * @return inputTextPane
	 * 				JTextPane for the panel
	 */
	private JTextPane prepareJTextPane() {
		JTextPane inputTextPane = new JTextPane();
		inputTextPane.setFont(font);
		inputTextPane.setEditable(false);
		((AbstractDocument) inputTextPane.getDocument()).setDocumentFilter(new CustomizedDocumentFilter(inputTextPane));

		return inputTextPane;
	}

	/**
	 * This method will prepare the focus of the window onto inputField.
	 * 
	 * @return boolean on success of execution
	 */
	public boolean setInputFocus() {
		return inputField.requestFocusInWindow();
	}

	/**
	 * This method will set the text pane
	 * to null for clearing text.
	 * 
	 */
	public static void setPaneToNull(){
		textPane.setText(null);
	}

	/**
	 * This method will display and print out
	 * the error message.
	 * 
	 * @param msg
	 * 				String msg to be displayed
	 */
	public static void displayError(String msg){
		errorLabel.setText(msg);
		if (!errorTimer.isRunning()) {
			errorPanel.setVisible(true);
			errorTimer.start();
		}
	}
	
	/**
	 * This method will update and print out
	 * the given string.
	 * 
	 * @param msg
	 * 				String msg to be displayed
	 */
	public static void updatePrint(String msg){
		append(commandList.getLast().getData(), true);
		append(msg +NEXT_LINE, false);
	}

	/**
	 * This method prepare the reminder panel 
	 * to display the reminders of tasks.
	 * 
	 * @param taskList
	 * 				array list of tasks 
	 */
	public void createReminder(final ArrayList<Task> taskList){
		//System.out.println("Reminder alert");
		if (reminderDialog == null) {
			javax.swing.SwingUtilities.invokeLater(new Runnable() {
				public void run() {
					Window topWindow = SwingUtilities.getWindowAncestor(panel);
					reminderDialog = new JDialog(topWindow, MODAL_OPTION , ModalityType.APPLICATION_MODAL);
					reminderDialog.getContentPane().add(new ReminderPanel(taskList, reminderDialog).getMainPanel());
					reminderDialog.pack();
					reminderDialog.setLocationRelativeTo(topWindow);
					reminderDialog.setLocation(reminderDialog.getLocation().x, 0);
					reminderDialog.setVisible(true);
				}
			});

		} else {
			reminderDialog.getContentPane().add(new ReminderPanel(taskList, reminderDialog).getMainPanel());
			reminderDialog.pack();
			reminderDialog.setVisible(true);
		}
	}

	/**
	 * This method sets the dialog to null
	 * for next reminder.
	 * 
	 */
	public static void setDialogNull(){
		reminderDialog = null;
	}
	
	public void triggerCommandSuggestor(){
		commandSuggestor.checkForAndShowSuggestions();
	}

	/**
	 * This method processes the key pressed by user
	 * and specifically looks for key up and key down
	 * to perform histories of commands.
	 * 
	 */
	@Override
	public void keyPressed(KeyEvent e) {
		int keyCode = e.getKeyCode();
		switch( keyCode ) { 
		case KeyEvent.VK_UP:
			// handle up 
			historyOnUp();
			break;
		case KeyEvent.VK_DOWN:
			// handle down
			historyOnDown();
			break;
		case KeyEvent.VK_LEFT:
			// handle left
			break;
		case KeyEvent.VK_RIGHT :
			// handle right
			break;
		}
	}

	/**
	 * This method keeps track of the
	 * history of the commands keyed by users and
	 * on down button. It will display the history which 
	 * is more recent. If it is most recent,
	 * it will not change anymore.
	 * 
	 */
	public void historyOnDown() {
		if(node != null){
			if(node.getNext()!=null){
				node = node.getNext();
				inputField.setText(node.getData());
			} else{
				if(currentCommand!=null){
					inputField.setText(currentCommand);
					currentCommand = null;
				}
			}
		}
	}

	/**
	 * This method keeps track of the
	 * history of the commands keyed by users and
	 * on up button. It will display the history which is 
	 * previously typed, in chronological order. If it is 
	 * the last of the commands keyed, it will not change anymore.
	 * Current command keyed will be saved on the cache and can
	 * be retrieved by down button.
	 * 
	 */
	public void historyOnUp() {
		if(node == null){
			node = commandList.getLast();
			if(currentCommand == null){
				currentCommand = inputField.getText();
			}
			if(node!=null){
				inputField.setText(node.getData());
			}

		} else{
			if(node.getPrevious()!=null){
				node = node.getPrevious();
				if(currentCommand == null){
					currentCommand = inputField.getText();
					node = commandList.getLast();
				}
				inputField.setText(node.getData());
			}
		}
	}

```
###### src\main\paddletask\ui\view\ReminderPanel.java
``` java
package main.paddletask.ui.view;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.text.AbstractDocument;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.SimpleAttributeSet;

import main.paddletask.task.entity.Task;
import main.paddletask.ui.controller.UIController;

public class ReminderPanel {
	
	/*** Variables ***/
	private ArrayList<Task> taskList = null;
	private static final String TITLE = "PaddleTask Reminder";
	private static final String CLOSE_MSG = "Close";
	private static final String NEXT_LINE = "\n";
	private static final String OPTION_MAXIMIZE = "Maximize";
	private static final String OPTION_ICONIFY = "Iconify";
	private static final String OPTION_CLOSE = "Close";
	private static final String STRING_EMPTY = "";
	private static final char PRIORITY_INDICATOR = '*';
	private static final char BOLD_INDICATOR = '@';
	private static final int OFFSET_ZERO = 0;
	private static final int SUBSTRING_BEGIN = 1;
	private JPanel reminderPanel = new JPanel();
	private JTextPane textPane;
	private JDialog dialog;
	private JButton okButton;
	private static Font font = new Font("Consolas",Font.BOLD, 15);
	private Box box = null;
	private static final int HEIGHT = 4;
	private static final int WIDTH = 2;
	private static final Color backgroundColor = new Color(180, 0, 0); //Red color
	
	/*** Constructors ***/
	public ReminderPanel(ArrayList<Task> taskList, JDialog dialog){
		this.taskList = taskList;
		this.dialog = dialog;
		dialog.setTitle(TITLE);
		removeDefaultButtons(dialog);
		preparePanelComponents();
		processArrayList();
	}
	
	/*** Methods ***/
	/**
	 * This method process the array lists given
	 * and formats it by calling uiController.
	 * Followed after will be preparing to append
	 * the text for display. 
	 * 
	 */
	private void processArrayList(){
		UIController uiController = UIController.getInstance(null);
		String[] output = uiController.format(taskList);
		append(output);
	}

	/**
	 * This method prepares the panel layout
	 * and all the necessary components needed for
	 * PaddleTask to display reminders.
	 * 
	 */
	private void preparePanelComponents() {
		reminderPanel.setLayout(new BoxLayout(reminderPanel, BoxLayout.PAGE_AXIS));
		textPane = prepareJTextPane();
		JScrollPane scrollPane = prepareScrollPane(textPane);
		okButton = prepareButton();
		prepareBoxComponent(scrollPane);
		prepareBoxComponent(okButton);
		reminderPanel.add(box, BorderLayout.PAGE_END);
	}
	
	/**
	 * This method prepares a scroll pane for the textPane to enable scrolling
	 * for display.
	 * 
	 * @param textPane
	 * 				JTextPane of the panel

	 * @return areaScrollPane 
	 * 				JScrollPane with textPane
	 */
	private JScrollPane prepareScrollPane(JTextPane textPane) {
		JScrollPane areaScrollPane = new JScrollPane(textPane);
		areaScrollPane.setVerticalScrollBarPolicy(
				JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		areaScrollPane.setAutoscrolls(true);
		return areaScrollPane;
	} 
	
	/**
	 * This method gets the reminderPanel when called.
	 * 
	 * @return textArea
	 * 				JTextPane of the panel
	 */
	public JPanel getMainPanel(){
		return reminderPanel;
	}
	
	/**
	 * This method prepares a box component to be created on the panel.
	 * Aligns the component together in a box layout vertically.
	 * 
	 * @param comp
	 * 				Component to be added into box		
	 * @return box
	 * 			Box formatting with the components on the panel
	 */
	public Box prepareBoxComponent(Component comp) {
		if(box == null){
			box = Box.createVerticalBox();
		}
		box.add(comp,BorderLayout.CENTER);
		return box;
	}
	
	/**
	 * This method prepares a text pane for the 
	 * output of the program to be displayed on.
	 * 
	 * @return inputTextPane
	 * 				JTextPane for the panel
	 */
	private JTextPane prepareJTextPane() {
		JTextPane inputTextPane = new JTextPane();
		inputTextPane.setFont(font);
		inputTextPane.setEditable(false);
		((AbstractDocument) inputTextPane.getDocument()).setDocumentFilter(new CustomizedDocumentFilter(inputTextPane));
        Dimension size = reminderPanel.getToolkit().getScreenSize();
        size.setSize(size.width / WIDTH , size.height / HEIGHT);
        inputTextPane.setPreferredSize(size);

		return inputTextPane;
	}
	
	/**
	 * This method prepares a button to allow the user
	 * to close the reminder when clicked.
	 * 
	 * @return textArea
	 * 				JTextPane of the panel
	 */
	public JButton prepareButton(){
		JButton button = new JButton();
		button.setText(CLOSE_MSG);
		button.setAlignmentX(Component.CENTER_ALIGNMENT);
		button.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				dialog.dispose();
				MainPanel.setDialogNull();
			}
		});
		return button;
	}
	
	/**
	 * This method appends a string of text into the textPane to display to the user
	 * 
	 * @param s
	 *        	String s to be appended to textPane
	 */
	public void append(String s) {
		try {
			Document doc = textPane.getDocument();
			textPane.setCaretPosition(doc.getLength());
			doc.insertString(doc.getLength(), s + NEXT_LINE + NEXT_LINE, null);
		} catch(BadLocationException exc) {
			assert false;
			exc.printStackTrace();
		}

	}

	/**
	 * This method appends a string array of text into the textPane to display to the user
	 * 
	 * @param output
	 * 			String[] to be appended to textPane
	 *        	   
	 */
	public void append(String[] output){
		try {
			Document doc = textPane.getDocument();
			textPane.setCaretPosition(doc.getLength());
			String outputString = STRING_EMPTY;
			for(String s : output ){
				if(s != null){
					outputString = s + NEXT_LINE;
					SimpleAttributeSet color = new SimpleAttributeSet();
					if(outputString.charAt(OFFSET_ZERO)==BOLD_INDICATOR){
						color.addAttributes(CustomizedDocumentFilter.setBold());
						outputString = outputString.substring(SUBSTRING_BEGIN);
						color.addAttributes(CustomizedDocumentFilter.setBackgroundColorForHeader(backgroundColor));
						color.addAttributes(CustomizedDocumentFilter.changeToWhite());
					}
					if(outputString.charAt(OFFSET_ZERO)==PRIORITY_INDICATOR){
						color.addAttributes(CustomizedDocumentFilter.changeToOrange());
						outputString = outputString.substring(SUBSTRING_BEGIN);
					}
					if(outputString.charAt(OFFSET_ZERO)==PRIORITY_INDICATOR){
						color.addAttributes(CustomizedDocumentFilter.changeToRed());
						outputString = outputString.substring(SUBSTRING_BEGIN);
					}
					doc.insertString(doc.getLength(), outputString, color);
				}
			}
			doc.insertString(doc.getLength(), NEXT_LINE, null);
		} catch(BadLocationException exc) {
			assert false;
			exc.printStackTrace();
		}
	}
	
	/**
	 * This method removes the default buttons of minimize, maximise and close
	 * on the Dialog. 
	 * 
	 *  @param  Component 
	 *  			JDialog reminderDialog
	 */
	
	public static void removeDefaultButtons(Component com){
		if(com instanceof JButton){
			String name = ((JButton) com).getAccessibleContext().getAccessibleName();
			if(name.equals(OPTION_MAXIMIZE)|| name.equals(OPTION_ICONIFY)||
					name.equals(OPTION_CLOSE)){
				com.getParent().remove(com);
			}
		}
		if (com instanceof Container){
			Component[] comps = ((Container)com).getComponents();
			for(int x = 0, y = comps.length; x < y; x++){
				removeDefaultButtons(comps[x]);
			}
		}
	}
	
}
```
###### src\test\cases\FullSystemFlowTest.java
``` java
package test.cases;

import static org.junit.Assert.assertArrayEquals;

import java.io.File;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import main.paddletask.storage.api.StorageController;
import main.paddletask.ui.view.MainFrame;

public class FullSystemFlowTest {
    StorageController sController;
    protected static String fileName;
    byte[] backedUpContent = null;
    
	@Before
	public void setUp() throws Exception {
        sController = StorageController.getInstance();
        fileName = StorageController.DEFAULT_FILE;
        backUpData();
	}

	@After
	public void tearDown() throws Exception {
		 restoreData();
	}

	@Test
	public void testAddFloating() {
		String input = "add watch movie";
		String[] expected = {"New task added successfully\n","Description: watch movie", "Task Type: floating", "Priority: 3", "\n"};
		String[] actual = MainFrame.testDriver(input);
		System.out.println("add test");
		assertArrayEquals(expected, actual);
	}
	
	@Test
	public void testAddDeadline() {
		String input = "add watch movie by 10/12/2014 23:59";
		String[] expected = {"New task added successfully\n","Description: watch movie", 
				"Task Type: deadline", "Priority: 3", "Deadline: 10/12/2014 23:59",
				"Reminder: 10/12/2014 23:54","\n"};
		String[] actual = MainFrame.testDriver(input);

		assertArrayEquals(expected, actual);
	}
	
	/*@Test
	public void testEdit() {
		String[] input = {"view all", "edit 1 priority 1"};
		String[] expected = {"Selected task edit successfully\n","Description: watch movie", 
				"Task Type: deadline", "Priority: 1", "Deadline: 10/12/2014 23:59",
				"Reminder: 10/12/2014 23:54","\n"};
		String[] actual = MainFrame.testDriver(input);

		assertArrayEquals(expected, actual);
	}*/
	
```
###### src\test\cases\TestViewCommand.java
``` java
package test.cases;

import static org.junit.Assert.*;

import java.util.ArrayList;
import org.junit.Test;
import main.paddletask.command.api.ViewTaskCommand;
import main.paddletask.task.entity.Task;

public class TestViewCommand {
	@Test
	public void testViewByType() throws Exception{
		ViewTaskCommand view = new ViewTaskCommand();
		@SuppressWarnings("unused")
		ArrayList<Task> allTask = new ArrayList<Task>();
		assertNotNull(view.execute());
		//view.selectTaskByPeriod(allTask);
	}
}
```
