# A0126332R
###### src\main\paddletask\background\Reminder.java
``` java
package main.paddletask.background;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;

import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.TimedTask;

public class Reminder extends Observable {
    private static final int _61 = 61;
    /*** Variables ***/
    private static Reminder _thisInstance;
    private static Observer _observer;
    private static Thread _thread;
    private static Runnable _runnable;

    /*** Constructor ***/
    private Reminder() {
        addObserver(_observer);
        createRunnable();
        _thread = new Thread(_runnable);
        _thread.start();
        //System.out.println("Reminder Thread started...\n");
    }

    public static Reminder getInstance(Observer reminderObserver) {
        if (_thisInstance == null) {
            _observer = reminderObserver;
            _thisInstance = new Reminder();
        }
        return _thisInstance;
    }
    
    /*** Methods ***/
    /**
     * This method creates a runnable that
     * runs in the background
     * 
     */
    private void createRunnable() {
        _runnable = new Runnable() {
            public void run() {
                while (true) {
                    // Retrieve task
                    ArrayList<Task> tasks = Task.getTaskList();

                    // Get task with reminders in the next minute
                    ArrayList<Task> dueTasks = new ArrayList<Task>();
                    LocalDateTime reminder;
                    LocalDateTime now = LocalDateTime.now();
                    Duration duration;
                    if(tasks != null){
                        for (Task task : tasks) {
                            // Select tasks that are not completed only
                            if (!task.isComplete()) {
                                switch (task.getType()) {
                                case TIMED:
                                    reminder = ((TimedTask) task).getReminder();
                                    duration = Duration.between(reminder, now);
                                    if ((reminder.isAfter(now)) && (Math.abs(duration.getSeconds()) < _61)) {
                                        dueTasks.add(task);
                                    }
                                    break;
                                case DEADLINE:
                                    reminder = ((DeadlineTask) task).getReminder();
                                    duration = Duration.between(reminder, now);
                                    if ((reminder.isAfter(now)) && (Math.abs(duration.getSeconds()) < _61)) {
                                        dueTasks.add(task);
                                    }
                                    break;
                                default:
                                    break;
                                }
                            }
                        }
                    }
                    
                    //System.out.println("dueTaskList.size(): " + dueTaskList.size());

                    // Notify observers
                    if (dueTasks.size() > 0) {
                        setChanged();
                        notifyObservers(dueTasks);
                    }

                    // Sleep for 1 minute
                    try {
                        //System.out.println("Go to sleep");
                        Thread.sleep(60000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
    }
}
```
###### src\main\paddletask\command\api\CompleteTaskCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;
import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.Task;

public class CompleteTaskCommand extends Command {

    /*** Variables ***/
    private static final int NEGATIVE_ONE = -1;
    private static final String KEYWORD_COMPLETE = "complete";
    private static ArrayList<Task> completedTaskList;
    
    private TaskController taskController;
    
    /*** Methods ***/
    /**
     * This method complete Tasks based on user input
     * 
     * @return an ArrayList of Task objects that contains the completed Task
     *         objects
     */
    @Override
    public ArrayList<Task> execute() {
        taskController = TaskController.getInstance();
        if (hasOption(KEYWORD_COMPLETE)) {
            completedTaskList = completeTask();
            return completedTaskList;
        } else {
            return null;
        }
    }
    
    /**
     * This method complete Tasks based on taskId
     * 
     * @return an ArrayList of Task objects that contains the completed Task
     *         objects
     */
    private ArrayList<Task> completeTask() {
        ArrayList<Task> taskList = new ArrayList<Task>();
        boolean deleteTaskResult = false;
        int numOfValues = NEGATIVE_ONE;
        
        numOfValues = getOption(KEYWORD_COMPLETE).getValuesCount();
        
        for (int i = 0; i < numOfValues; i++) {
            // Get params
            int taskId = NEGATIVE_ONE;
            taskId = getOption(KEYWORD_COMPLETE).getIntegerValue(i);
            
            // Check if task exist
            Task task = taskController.getTask(taskId);
            
            // Update task
            if (task != null) {
                task.setComplete(true);
                deleteTaskResult = taskController.updateTask(task);
                
                if (deleteTaskResult == true) {
                    taskList.add(task);
                } else {
                    return taskList;
                }
            }
        }
        
        return taskList;
    }

    /**
     * This method reverse the previous execute() of the previous
     * CompleteTaskCommand
     * 
     * @return an ArrayList of Task objects that contains the completed Task
     *         objects
     */
    @Override
    public ArrayList<Task> undo() {
        if (completedTaskList != null) {
            for (Task task : completedTaskList) {
                task.setComplete(!task.isComplete());
                TaskController.getInstance().updateTask(task);
            }
        }
        return completedTaskList;
    }
}
```
###### src\main\paddletask\command\api\DeleteTaskCommand.java
``` java
package main.paddletask.command.api;

import java.time.LocalDateTime;
import java.util.ArrayList;

import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.TimedTask;

public class DeleteTaskCommand extends Command {

    /*** Variables ***/
    private static final String KEYWORD_DELETE = "delete";
    private static final String KEYWORD_BETWEEN = "between";
    private static final String KEYWORD_AND = "and";
    private static ArrayList<Task> _deletedTasks;
    
    private TaskController taskController;
    
    /*** Methods ***/
    /**
     * This method delete Tasks based on user input
     * 
     * @return an ArrayList of Task objects that contains the deleted Task
     *         objects
     */
    @Override
    public ArrayList<Task> execute() {
        taskController = TaskController.getInstance();
        if (hasOption(KEYWORD_DELETE) && getOption(KEYWORD_DELETE) != null) {
            _deletedTasks = deleteByTaskId();
            return _deletedTasks;
        } else if (hasOption(KEYWORD_BETWEEN) && hasOption(KEYWORD_AND)) {
            _deletedTasks = deleteByPeriod();
            return _deletedTasks;
        } else {
            return null;
        }
    }
    
    /**
     * This method delete Tasks based on taskId
     * 
     * @return an ArrayList of Task objects that contains the deleted Task
     *         objects
     */
    private ArrayList<Task> deleteByTaskId() {
        ArrayList<Task> tasks = new ArrayList<Task>();
        boolean deleteTaskResult = false;
        int numOfValues = -1;
        
        numOfValues = getOption(KEYWORD_DELETE).getValuesCount();
        
        for (int i = 0; i < numOfValues; i++) {
            // Get params
            int taskId = -1;
            taskId = getOption(KEYWORD_DELETE).getIntegerValue(i);
            
            // Check if task exist
            Task task = taskController.getTask(taskId);
            
            // Delete task
            if (task != null) {
                deleteTaskResult = taskController.deleteTask(taskId);
                if (deleteTaskResult == true) {
                    tasks.add(task);
                } else {
                    break;
                }
            }
        }
        
        return tasks;
    }
    
    /**
     * This method delete Tasks based on a user defined period of time
     * 
     * @return an ArrayList of Task objects that contains the deleted Task
     *         objects
     */
    private ArrayList<Task> deleteByPeriod() {
        ArrayList<Task> tasks = new ArrayList<Task>();
        boolean deleteTaskResult = false;
        
        // Get period
        LocalDateTime start = getOption(KEYWORD_BETWEEN).getDateValue();
        LocalDateTime end = getOption(KEYWORD_AND).getDateValue();
        
        // Get task within period
        ArrayList<Task> filteredtaskList = getTaskByPeriod(start, end);
        
        // Delete task
        for (int i = 0; i < filteredtaskList.size(); i++) {
            Task task = filteredtaskList.get(i);
            deleteTaskResult = taskController.deleteTask(task.getTaskId());
            if (deleteTaskResult == true) {
                tasks.add(task);
            } else {
                break;
            }
        }
        
        return tasks;
    }

    /**
     * This method retrieves a Task based on a user defined period of time
     * 
     * @param  start  start of the time period
     * @param  end    end of the time period
     * @return        an ArrayList of Task objects that is within the period
     */
    private ArrayList<Task> getTaskByPeriod(LocalDateTime start, LocalDateTime end) {
        ArrayList<Task> allTasks = taskController.getTask();
        ArrayList<Task> filteredTasks = new ArrayList<Task>();
        
        for (Task task : allTasks) {
            switch (task.getType()) {
                case FLOATING:
                    break;
                case TIMED:
                    if ((((TimedTask) task).getStart().compareTo(start) >= 0) &&
                            (((TimedTask) task).getEnd().compareTo(end) <= 0)) {
                        filteredTasks.add(task);
                    }
                    break;
                case DEADLINE:
                    if ((((DeadlineTask) task).getEnd().compareTo(start) >= 0) && 
                            (((DeadlineTask) task).getEnd().compareTo(end) <= 0)) {
                        filteredTasks.add(task);
                    }
                    break;
                default:
                    break;
            }
        }
        
        return filteredTasks;
    }

    /**
     * This method reverse the previous execute() of the previous
     * DeleteTaskCommand
     * 
     * @return an ArrayList of Task objects that contains the deleted Task
     *         objects
     */
    @Override
    public ArrayList<Task> undo() {
        if (_deletedTasks != null) {
            for (Task task : _deletedTasks) {
                TaskController.getInstance().addTask(task);
            }
        }
        return _deletedTasks;
    }

}
```
###### src\main\paddletask\command\api\SetDirectoryCommand.java
``` java
package main.paddletask.command.api;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;

import main.paddletask.storage.api.StorageController;
import main.paddletask.task.entity.Task;

public class SetDirectoryCommand extends Command {

    /*** Variables ***/
    private static final String NEW_PATH_ERROR = "Error in setting new path: ";
    private static final String NEW_PATH_SET = "New path set: ";
    private static final String KEYWORD_SET_DIRECTORY = "setdirectory";
    private static String _oldPath = "";
    
    /*** Methods ***/
    /**
     * This method set the xml data file path based on user input,
     * copy the existing file to the new path
     * and call the observer to display the status of the operation
     * 
     */
    @Override
    public ArrayList<Task> execute() throws Exception {
        StorageController storageController = StorageController.getInstance();
        String newPath = null;
        String comments = null;
        
        // Get new path
        if (hasOption(KEYWORD_SET_DIRECTORY)) {
            newPath = getOption(KEYWORD_SET_DIRECTORY).getStringValue();
        }
        
        // Store old path for undoing
        byte[] content = storageController.getFileInBytes(StorageController.CONFIG_FILE);
        _oldPath = new String(content, StandardCharsets.UTF_8);
        
        // Set new path
        boolean success = storageController.setDirectory(newPath);
        if (success) {
            comments = NEW_PATH_SET + newPath;
        } else {
            comments = NEW_PATH_ERROR + newPath;
        }
        setChanged();
        notifyObservers(comments);
        return null;
    }
    
    /**
     * This method undo the setting of the new file path
     * and revert to the existing file path
     * 
     */
    @Override
    public ArrayList<Task> undo() throws Exception {
        StorageController storageController = StorageController.getInstance();
        String comments = null;
        
        // Set new path
        boolean success = storageController.setDirectory(_oldPath);
        if (success) {
            comments = NEW_PATH_SET + _oldPath;
        } else {
            comments = NEW_PATH_ERROR + _oldPath;
        }
        setChanged();
        notifyObservers(comments);
        return null;
    }
    
}
```
###### src\main\paddletask\storage\api\StorageController.java
``` java
package main.paddletask.storage.api;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import main.paddletask.common.util.DateTimeHelper;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.FloatingTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.Task.RECUR_TYPE;
import main.paddletask.task.entity.TimedTask;
import main.paddletask.task.entity.Task.TASK_TYPE;

public class StorageController {
    /*** Variables ***/
    private static final String ERROR_INITIALIZING_TRANSFORMER = "Error initializing transformer";
    private static final String ERROR_OUTPUTTING_DOCUMENT = "Error outputting document";
    private static final String ERROR_WRITING_TO_FILE = "Error writing to file";
    private static final String YES = "yes";
    private static final String INDENT_AMOUNT = "4";
    private static final String INDENT_AMOUNT_DOCS = "{http://xml.apache.org/xslt}indent-amount";
    private static final String ENCODING = "ISO-8859-1";
    private static final String TASK = "task";
    private static final String RECURTYPE = "recurtype";
    private static final String RECURRING = "recurring";
    private static final String REMINDER = "reminder";
    private static final String END = "end";
    private static final String START = "start";
    private static final String TAG = "tag";
    private static final String PRIORITY = "priority";
    private static final String COMPLETE = "complete";
    private static final String TASKTYPE = "tasktype";
    private static final String CREATED_AT = "createdAt";
    private static final String DESCRIPTION = "description";
    private static final String TASK_ID = "taskId";
    private static final String ITEM = "item";
    private static final String DEFAULT_XML = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?><task></task>";
    public static final String CONFIG_FILE = ".config";
    protected static String DEFAULT_FILE = "task.xml";
    private static StorageController _thisInstance;
    
    /*** Constructor ***/
    private StorageController() {
        setFileName();
    }
    
    public static StorageController getInstance() {
        if (_thisInstance == null) {
            _thisInstance = new StorageController();
        }
        return _thisInstance;
    }
    
    /*** Methods ***/
    /**
     * This method get the file location from the config file
     * returning the default file path if it does not exit
     * 
     * @return      file name
     */
    protected boolean setFileName() {
        File file = new File(CONFIG_FILE);
        if (!file.exists()) {
         // Create file if it does not exist
            try {
                file.createNewFile();
                FileWriter fileWriter = new FileWriter(CONFIG_FILE);
                fileWriter.write(DEFAULT_FILE);
                fileWriter.close();
            } catch (IOException e) {
                e.printStackTrace();
                return false;
            }
        } else {
            // Read the file name from file
            byte[] content = getFileInBytes(CONFIG_FILE);
            DEFAULT_FILE = new String(content, StandardCharsets.UTF_8);
        }
        return true;
    }
    
    /**
     * This method set the new path of the xml file
     * It will copy the existing xml file to the new location
     * 
     * @param  newPath  the new path of the xml file
     * @return          success status
     */
    public boolean setDirectory(String newPath) {
        boolean success;
        // Get existing content
        byte[] content = getFileInBytes(DEFAULT_FILE);
        
        // Copy data to new path
        success = writeBytesToFile(newPath, content, false);
        if (success) {
            // Write new path to CONFIG
            success = writeBytesToFile(CONFIG_FILE, newPath.getBytes(), false);
            if (success) {
                DEFAULT_FILE = newPath;
                Task.setTaskList(readTask());
                return success;
            } else {
                return success;
            }
        } else {
            return success;
        }
    }
    
    /**
     * This method retrieves a File object
     * 
     * @param  fileName  the full file path
     * @return           file object
     */
    protected File getFile(String fileName) {
        File file = new File(fileName);
        if (!file.exists()) {
            return null;
        }
        return file;
    }
    
    /**
     * This method retrieves the bytes of a File
     * 
     * @param  fileName  the full file path
     * @return           byte array of the file content
     */
    public byte[] getFileInBytes(String fileName) {
        byte[] content = null;
        try {
            Path filePath = Paths.get(fileName);
            content = Files.readAllBytes(filePath);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return content;
    }
    
    /**
     * This method writes bytes to a File
     * creating the file if it does not exist
     * 
     * @param  fileName  the full file path
     * @param  content   the bytes to be written
     * @param  append    whether the content should be appended or overwritten
     * @return           success status
     */
    public boolean writeBytesToFile(String fileName, byte[] content, boolean append) {
        File file = new File(fileName);
        if (!file.exists()) {
         // Create file if it does not exist
            try {
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
                return false;
            }
        }
        
        try {
            FileOutputStream fileOutputStream = new FileOutputStream(fileName, append);
            fileOutputStream.write(content);
            fileOutputStream.close();
        } catch (IOException ioe) {
            ioe.printStackTrace();
            return false;
        }
        return true;
    }
    
    /**
     * This method creates a new XML file 
     * 
     * @param  fileName  the full file path
     * @return           file containing Task objects
     */
    protected File getXmlFile(String fileName) {
        File file = getFile(fileName);
        if (file == null) {
            // Create file if it does not exist
            try {
                file = new File(fileName);
                file.createNewFile();
                String xml = DEFAULT_XML;
                FileWriter fileWriter = new FileWriter(fileName);
                fileWriter.write(xml);
                fileWriter.close();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }
        return file;
    }
    
    /**
     * This method reads all the Task objects to an ArrayList
     * 
     * @return       ArrayList of all Task objects
     */
    public ArrayList<Task> readTask() {
        ArrayList<Task> tasks = new ArrayList<Task>();
        try {
            Document doc = parseXml();
            
            //~ System.out.println("Root element :" + doc.getDocumentElement().getNodeName());
            NodeList nodeList = doc.getElementsByTagName(ITEM);
            
            for (int temp = 0; temp < nodeList.getLength(); temp++) {
                Node node = nodeList.item(temp);
                Task task = null;
                //System.out.println("\nCurrent Element :" + nNode.getNodeName());
                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    Element element = (Element) node;
                    
                    // taskId
                    String taskId = element.getElementsByTagName(TASK_ID).item(0).getTextContent();
                    int taskIdAsInt = Integer.valueOf(taskId);
                    
                    // description
                    String description = element.getElementsByTagName(DESCRIPTION).item(0).getTextContent();
                    
                    // createdAt
                    String createdAt = element.getElementsByTagName(CREATED_AT).item(0).getTextContent();
                    LocalDateTime createdAtAsLocalDateTime = DateTimeHelper.parseStringToDateTime(createdAt);
                    
                    // task type
                    String taskTypeAsString = element.getElementsByTagName(TASKTYPE).item(0).getTextContent();
                    TASK_TYPE taskType = Task.determineTaskType(taskTypeAsString);
                    
                    // complete
                    String complete = element.getElementsByTagName(COMPLETE).item(0).getTextContent();
                    boolean isCompleteAsBoolean = Boolean.valueOf(complete);
                    
                    // priority
                    String priority = element.getElementsByTagName(PRIORITY).item(0).getTextContent();
                    int priorityAsInt = Integer.valueOf(priority);
                    
                    // tags
                    String tag = element.getElementsByTagName(TAG).item(0).getTextContent();
                    ArrayList<String> tagsAsArray = getTagsInArrayList(tag);
                    
                    String start;
                    LocalDateTime startAsLocalDateTime;
                    String end;
                    LocalDateTime endAsLocalDateTime;
                    String reminder;
                    LocalDateTime reminderAsLocalDateTime;
                    String recurring;
                    boolean isRecurringAsBoolean;
                    String recurTypeAsString;
                    RECUR_TYPE recurType;
                    switch (taskType) {
                        case FLOATING:
                            task = new FloatingTask(taskIdAsInt, description, createdAtAsLocalDateTime, isCompleteAsBoolean, priorityAsInt, tagsAsArray);
                            break;
                        case TIMED:
                            // start
                            start = element.getElementsByTagName(START).item(0).getTextContent();
                            startAsLocalDateTime = DateTimeHelper.parseStringToDateTime(start);
                            
                            // end
                            end = element.getElementsByTagName(END).item(0).getTextContent();
                            endAsLocalDateTime = DateTimeHelper.parseStringToDateTime(end);
                            
                            // reminder
                            reminder = element.getElementsByTagName(REMINDER).item(0).getTextContent();
                            reminderAsLocalDateTime = DateTimeHelper.parseStringToDateTime(reminder);
                            
                            // recurring
                            recurring = element.getElementsByTagName(RECURRING).item(0).getTextContent();
                            isRecurringAsBoolean = Boolean.valueOf(recurring);
                            
                            // recur type
                            recurTypeAsString = element.getElementsByTagName(RECURTYPE).item(0).getTextContent();
                            recurType = Task.determineRecurType(recurTypeAsString);
                            
                            task = new TimedTask(taskIdAsInt, description, createdAtAsLocalDateTime, startAsLocalDateTime, endAsLocalDateTime, reminderAsLocalDateTime, isCompleteAsBoolean, priorityAsInt, tagsAsArray, isRecurringAsBoolean, recurType);
                            break;
                        case DEADLINE:
                            // end
                            end = element.getElementsByTagName(END).item(0).getTextContent();
                            endAsLocalDateTime = DateTimeHelper.parseStringToDateTime(end);
                            
                            // reminder
                            reminder = element.getElementsByTagName(REMINDER).item(0).getTextContent();
                            reminderAsLocalDateTime = DateTimeHelper.parseStringToDateTime(reminder);
                            
                            // recurring
                            recurring = element.getElementsByTagName(RECURRING).item(0).getTextContent();
                            isRecurringAsBoolean = Boolean.valueOf(recurring);
                            
                            // recur type
                            recurTypeAsString = element.getElementsByTagName(RECURTYPE).item(0).getTextContent();
                            recurType = Task.determineRecurType(recurTypeAsString);
                            
                            task = new DeadlineTask(taskIdAsInt, description, createdAtAsLocalDateTime, endAsLocalDateTime, reminderAsLocalDateTime, isCompleteAsBoolean, priorityAsInt, tagsAsArray, isRecurringAsBoolean, recurType);
                            break;
                        default:
                            break;
                    }
                }
                
                if (task != null) {
                    tasks.add(task);
                }
            }
        } catch (Exception e) {
            //e.printStackTrace();
            //return null;
        }
        
        return tasks;
    }
    
    /**
     * This method returns a string representation of the XML version of the Task objects
     * 
     * @param  tasks  an ArrayList of all Task objects
     * @return        a Document representing the XML document
     */
    public Document parseTask(ArrayList<Task> tasks) {
        Document doc = null;
        try {

            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            doc = dBuilder.newDocument();
            
            Element root = doc.createElement(TASK);
            doc.appendChild(root);
            
            //for (Task task : taskList) {
            for (int i = 0; i < tasks.size(); i++) {
                Task task = tasks.get(i);
                
                Element item = doc.createElement(ITEM);
                root.appendChild(item);

                // taskId
                Element taskId = doc.createElement(TASK_ID);
                taskId.appendChild(doc.createTextNode(Integer.toString(task.getTaskId())));
                item.appendChild(taskId);
                
                // description
                Element description = doc.createElement(DESCRIPTION);
                description.appendChild(doc.createTextNode(task.getDescription()));
                item.appendChild(description);
                
                // createdAt
                String formattedDateTime = DateTimeHelper.parseDateTimeToString(task.getCreatedAt());
                Element createdAt = doc.createElement(CREATED_AT);
                createdAt.appendChild(doc.createTextNode(formattedDateTime));
                item.appendChild(createdAt);
                
                // type
                Element taskType = doc.createElement(TASKTYPE);
                taskType.appendChild(doc.createTextNode(task.getType().toString()));
                item.appendChild(taskType);
                
                // complete
                Element complete = doc.createElement(COMPLETE);
                String complete_string = String.valueOf(task.isComplete());
                complete.appendChild(doc.createTextNode(complete_string));
                item.appendChild(complete);
                
                // priority
                Element priority = doc.createElement(PRIORITY);
                priority.appendChild(doc.createTextNode(Integer.toString(task.getPriority())));
                item.appendChild(priority);
                
                // tag
                Element tag = doc.createElement(TAG);
                tag.appendChild(doc.createTextNode(getTagsInString(task.getTags())));
                item.appendChild(tag);
                
                Element start;
                Element end;
                Element reminder;
                Element recurring;
                String recurringAsString;
                Element recurType;
                switch (task.getType()) {
                    case FLOATING:
                        // start
                        start = doc.createElement(START);
                        start.appendChild(doc.createTextNode(""));
                        item.appendChild(start);
                        
                        // end
                        end = doc.createElement(END);
                        end.appendChild(doc.createTextNode(""));
                        item.appendChild(end);
                        break;
                    case TIMED:
                        //start
                        start = doc.createElement(START);
                        formattedDateTime = DateTimeHelper.parseDateTimeToString(((TimedTask) task).getStart());
                        start.appendChild(doc.createTextNode(formattedDateTime));
                        item.appendChild(start);
                        
                        // end
                        end = doc.createElement(END);
                        formattedDateTime = DateTimeHelper.parseDateTimeToString(((TimedTask) task).getEnd());
                        end.appendChild(doc.createTextNode(formattedDateTime));
                        item.appendChild(end);
                        
                        // reminder
                        reminder = doc.createElement(REMINDER);
                        formattedDateTime = DateTimeHelper.parseDateTimeToString(((TimedTask) task).getReminder());
                        reminder.appendChild(doc.createTextNode(formattedDateTime));
                        item.appendChild(reminder);
                        
                        // recurring
                        recurring = doc.createElement(RECURRING);
                        recurringAsString = String.valueOf(((TimedTask) task).isRecurring());
                        recurring.appendChild(doc.createTextNode(recurringAsString));
                        item.appendChild(complete);
                        
                        // type
                        recurType = doc.createElement(RECURTYPE);
                        recurType.appendChild(doc.createTextNode(((TimedTask) task).getRecurPeriod().toString()));
                        item.appendChild(recurType);
                        
                        break;
                    case DEADLINE:
                        // start
                        start = doc.createElement(START);
                        start.appendChild(doc.createTextNode(""));
                        item.appendChild(start);
                        
                        // end
                        end = doc.createElement(END);
                        formattedDateTime = DateTimeHelper.parseDateTimeToString(((DeadlineTask) task).getEnd());
                        end.appendChild(doc.createTextNode(formattedDateTime));
                        item.appendChild(end);
                        
                        // reminder
                        reminder = doc.createElement(REMINDER);
                        formattedDateTime = DateTimeHelper.parseDateTimeToString(((DeadlineTask) task).getReminder());
                        reminder.appendChild(doc.createTextNode(formattedDateTime));
                        item.appendChild(reminder);
                        
                        // recurring
                        recurring = doc.createElement(RECURRING);
                        recurringAsString = String.valueOf(((DeadlineTask) task).isRecurring());
                        recurring.appendChild(doc.createTextNode(recurringAsString));
                        item.appendChild(complete);
                        
                        // type
                        recurType = doc.createElement(RECURTYPE);
                        recurType.appendChild(doc.createTextNode(((DeadlineTask) task).getRecurPeriod().toString()));
                        item.appendChild(recurType);
                        
                        break;
                    default:
                        break;
                }
            }
        } catch (ParserConfigurationException e) {
            String ERROR_BUILDING_DOCUMENT = "Error building document";
            System.out.println(ERROR_BUILDING_DOCUMENT);
        }
        return doc;
    }
    
    /**
     * This method parse the raw XML file to XML Document of Nodes
     * 
     * @return       XML Document of Nodes
     */
    protected Document parseXml() {
        Document doc = null;
        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            doc = dBuilder.parse(getXmlFile(DEFAULT_FILE));
            
            // Ensures that the XML DOM view of a document is identical
            doc.getDocumentElement().normalize();
        } catch (Exception e) {
            //e.printStackTrace();
        }
        
        return doc;
    }
    
    /**
     * This method writes all Task objects to file
     * 
     * @param  doc  a Document representing the XML document
     * @return      <code>true</code> if the tasks are successfully stored; 
     *              <code>false</code> otherwise.
     */
    public boolean writeXml(Document doc) {
        try {
            // Save the document to the disk file
            TransformerFactory tranFactory = TransformerFactory.newInstance();
            Transformer aTransformer = tranFactory.newTransformer();

            // format the XML nicely
            aTransformer.setOutputProperty(OutputKeys.ENCODING, ENCODING);

            aTransformer.setOutputProperty(
                    INDENT_AMOUNT_DOCS, INDENT_AMOUNT);
            aTransformer.setOutputProperty(OutputKeys.INDENT, YES);

            DOMSource source = new DOMSource(doc);
            
            FileWriter fileWriter = new FileWriter(DEFAULT_FILE);
            StreamResult result = new StreamResult(fileWriter);
            aTransformer.transform(source, result);

        } catch (IOException e) {
            System.out.println(ERROR_WRITING_TO_FILE);
            return false;
        } catch (TransformerConfigurationException e1) {
            System.out.println(ERROR_OUTPUTTING_DOCUMENT);
            return false;
        } catch (TransformerException e) {
            System.out.println(ERROR_INITIALIZING_TRANSFORMER);
            e.printStackTrace();
            return false;
        }   
        
        return true;
    }
    
    /**
     * This method converts an arraylist of tags into string
     * 
     * @param  tags  an arraylist of tags
     * @return       a string representation
     */
    public String getTagsInString(ArrayList<String> tags) { 
        String tagsAsString = "";
        for (String tag : tags) {
            tagsAsString += tag + " ";
        }
        return tagsAsString.trim();
    }
    
    /**
     * This method converts a string of tags delimited by space,
     * into an arraylist
     * 
     * @param  tags  a string of tags
     * @return       an arraylist representation
     */
    public ArrayList<String> getTagsInArrayList(String tags) { 
         ArrayList<String> tagsAsArray = new ArrayList<String>();
         String[] splittedTags = tags.split(" ");
         for (String tag : splittedTags) {
             tagsAsArray.add(tag);
         }
         return tagsAsArray;
    }
}
```
###### src\main\paddletask\task\api\TaskController.java
``` java
package main.paddletask.task.api;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;

import org.w3c.dom.Document;

import main.paddletask.common.util.DateTimeHelper;
import main.paddletask.storage.api.StorageController;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.Task.TASK_TYPE;
import main.paddletask.task.entity.TimedTask;

public class TaskController {
    /*** Variables ***/
    private static final int NEGATIVE_ONE = -1;
    protected StorageController sController;
    private static TaskController _thisInstance;

    /*** Constructor ***/
    private TaskController() {
        sController = StorageController.getInstance();
        Task.setTaskList(sController.readTask());
    }
    
    public static synchronized TaskController getInstance( ) {
        if (_thisInstance == null)
            _thisInstance = new TaskController();
        return _thisInstance;
     }

    /*** Methods ***/
    /**
     * This method adds the Task object to file
     * 
     * @param  task  Task entry to be added
     * @return       <code>true</code> if the task is successfully added;
     *               <code>false</code> otherwise.
     */
    public boolean addTask(Task task) {
        // Get and set the smallest available tasId
        int taskId = getAvailableTaskId();
        task.setTaskId(taskId);

        // Add this task to our arraylist
        ArrayList<Task> tasks = Task.getTaskList();
        tasks.add(task);
        Task.setTaskList(tasks);

        // Store to file
        Document doc = sController.parseTask(tasks);
        boolean isSuccessful = sController.writeXml(doc);

        return isSuccessful;
    }

    /**
     * This method returns a list of all tasks
     * 
     * @return      an ArrayList of Tasks
     */
    public ArrayList<Task> getTask() {
        checkRecurring();
        ArrayList<Task> tasks = Task.getTaskList();
        return tasks;
    }

    /**
     * This method returns a list of the specified tasks
     * 
     * @param  type  type of the Tasks to be selected
     * @return       an ArrayList of Tasks
     */
    public ArrayList<Task> getTask(TASK_TYPE type) {
        checkRecurring();
        ArrayList<Task> tasks = Task.getTaskList();
        
        if (type == TASK_TYPE.ANY) {
            return tasks;
        }
        
        ArrayList<Task> filteredTasks = new ArrayList<Task>();

        for (Task task : tasks) {
            if (task.getType() == type) {
                filteredTasks.add(task);
            }
        }

        return filteredTasks;
    }

    /**
     * This method returns a Task object
     * 
     * @param  taskId  the unique identifier of the Task object
     * @return         the specified Task object
     */
    public Task getTask(int taskId) {
        checkRecurring();
        ArrayList<Task> tasks = Task.getTaskList();
        for (Task task : tasks) {
            if (task.getTaskId() == taskId) {
                return task;
            }
        }
        return null;
    }

    /**
     * This method updates the Task object to file
     * 
     * @param  task  Task entry to be updated
     * @return       <code>true</code> if the task is successfully updated;
     *               <code>false</code> otherwise.
     */
    public boolean updateTask(Task task) {
        ArrayList<Task> tasks = Task.getTaskList();
        boolean isFound = false;

        // Find task
        for (int i = 0; i < tasks.size(); i++) {
            Task existingTask = tasks.get(i);
            if (existingTask.getTaskId() == task.getTaskId()) {
                tasks.set(i, task);
                isFound = true;
                break;
            }
        }

        // Return if task is not found
        if (!isFound) {
            return false;
        }

        // Store to file
        Task.setTaskList(tasks);
        Document doc = sController.parseTask(tasks);
        boolean isSuccessful = sController.writeXml(doc);

        return isSuccessful;
    }

    /**
     * This method delete the Task from file
     * 
     * @param  taskId  the unique identifier of the Task object
     * @return         <code>true</code> if the task is successfully updated;
     *                 <code>false</code> otherwise.
     */
    public boolean deleteTask(int taskId) {
        ArrayList<Task> tasks = Task.getTaskList();
        boolean isFound = false;

        // Find task
        for (int i = 0; i < tasks.size(); i++) {
            Task task = tasks.get(i);
            if (task.getTaskId() == taskId) {
                tasks.remove(i);
                isFound = true;
                break;
            }
        }

        // Return if task is not found
        if (!isFound) {
            return false;
        }

        // Store to file
        Task.setTaskList(tasks);
        Document doc = sController.parseTask(tasks);
        boolean isSuccessful = sController.writeXml(doc);

        return isSuccessful;
    }

    /**
     * This method marks a Task as completed
     * 
     * @param  taskId  the unique identifier of the Task object
     * @return         <code>true</code> if the task is successfully marked as completed;
     *                 <code>false</code> otherwise.
     */
    public boolean completeTask(int taskId) {
        ArrayList<Task> tasks = Task.getTaskList();
        Task task = null;
        boolean isFound = false;
        int index = NEGATIVE_ONE;

        // Find task
        for (int i = 0; i < tasks.size(); i++) {
            task = tasks.get(i);
            if (task.getTaskId() == taskId) {
                index = i;
                isFound = true;
                break;
            }
        }

        // Return if task is not found
        if (!isFound) {
            return false;
        }

        // Modify complete status
        task.setComplete(true);
        tasks.set(index, task);

        // Store to file
        Task.setTaskList(tasks);
        Document doc = sController.parseTask(tasks);
        boolean isSuccessful = sController.writeXml(doc);

        return isSuccessful;
    }

    /**
     * This method overwrites the entire file with an new list of Tasks
     * 
     * @param  tasks  list of the new Task objects
     * @return        <code>true</code> if the task is successfully marked as 
     *                completed;
     *                <code>false</code> otherwise.
     */
    public boolean writeAllToFile(ArrayList<Task> tasks) {
        // Store to file
        Task.setTaskList(tasks);
        Document doc = sController.parseTask(tasks);
        boolean isSuccessful = sController.writeXml(doc);

        return isSuccessful;
    }

    /**
     * This method gets the next available taskId
     * 
     * @return      an int as the next taskId
     */
    public int getAvailableTaskId() {
        ArrayList<Task> tasks = Task.getTaskList();
        
        if (tasks.size() == 0) {
            return 1;
        }
        
        int[] testArray = new int[tasks.size()];

        for (int i = 0; i < testArray.length; i++) {
            testArray[i] = tasks.get(i).getTaskId();
        }

        Arrays.sort(testArray);
        int smallest = testArray[0];
        int largest = testArray[testArray.length - 1];
        int smallestUnused = largest + 1;
        
        if (smallest > 1) {
            smallestUnused = 1;
        } else {
            for (int i = 2; i < largest; i++) {
                if (Arrays.binarySearch(testArray, i) < 0) {
                    smallestUnused = i;
                    break;
                }
            }
        }

        return smallestUnused;
    }
    
    /**
     * This method checks recurring tasks
     * and updates their end dates if necessary
     * 
     * @return <code>true</code> if the check is successfully performed; 
     *         <code>false</code> otherwise.
     */
    public boolean checkRecurring() {
        ArrayList<Task> tasks = Task.getTaskList();

        // Loop through all task
        for (int i = 0; i < tasks.size(); i++) {
            Task task = tasks.get(i);
            switch (task.getType()) {
                case DEADLINE:
                    if ((task.isComplete() == false) &&
                            ((DeadlineTask) task).getEnd().isBefore(LocalDateTime.now()) &&
                            (((DeadlineTask) task).isRecurring() == true)) {
                        LocalDateTime newEndDate = ((DeadlineTask) task).getEnd();
                        switch (((DeadlineTask) task).getRecurPeriod()) {
                            case DAY:
                                while (newEndDate.isBefore(LocalDateTime.now())) {
                                    newEndDate = DateTimeHelper.addDays(newEndDate, 1);
                                }
                                break;
                            case WEEK:
                                while (newEndDate.isBefore(LocalDateTime.now())) {
                                    newEndDate = DateTimeHelper.addWeeks(newEndDate, 1);
                                }
                                break;
                            case MONTH:
                                while (newEndDate.isBefore(LocalDateTime.now())) {
                                    newEndDate = DateTimeHelper.addMonths(newEndDate, 1);
                                }
                                break;
                            case YEAR:
                                while (newEndDate.isBefore(LocalDateTime.now())) {
                                    newEndDate = DateTimeHelper.addYears(newEndDate, 1);
                                }
                                break;
                            default:
                                break;
                        }
                        ((DeadlineTask) task).setEnd(newEndDate);
                        ((DeadlineTask) task).setReminder(newEndDate.minusMinutes(5));
                        tasks.set(i, task);
                    }
                    break;
                case TIMED:
                    if ((task.isComplete() == false) &&
                            ((TimedTask) task).getEnd().isBefore(LocalDateTime.now()) &&
                            (((TimedTask) task).isRecurring() == true)) {
                        LocalDateTime newEndDate = ((TimedTask) task).getEnd();
                        switch (((TimedTask) task).getRecurPeriod()) {
                        case DAY:
                            while (newEndDate.isBefore(LocalDateTime.now())) {
                                newEndDate = DateTimeHelper.addDays(newEndDate, 1);
                            }
                            break;
                        case WEEK:
                            while (newEndDate.isBefore(LocalDateTime.now())) {
                                newEndDate = DateTimeHelper.addWeeks(newEndDate, 1);
                            }
                            break;
                        case MONTH:
                            while (newEndDate.isBefore(LocalDateTime.now())) {
                                newEndDate = DateTimeHelper.addMonths(newEndDate, 1);
                            }
                            break;
                        case YEAR:
                            while (newEndDate.isBefore(LocalDateTime.now())) {
                                newEndDate = DateTimeHelper.addYears(newEndDate, 1);
                            }
                            break;
                        default:
                            break;
                        }
                        ((TimedTask) task).setEnd(newEndDate);
                        ((TimedTask) task).setReminder(newEndDate.minusMinutes(5));
                        tasks.set(i, task);
                    }
                    break;
                default:
                    break;
            }
        }

        // Store to file
        Task.setTaskList(tasks);
        Document doc = sController.parseTask(tasks);
        boolean isSuccessful = sController.writeXml(doc);

        return isSuccessful;
    }
}
```
###### src\main\paddletask\task\entity\DeadlineTask.java
``` java
package main.paddletask.task.entity;

import java.time.LocalDateTime;
import java.util.ArrayList;

import main.paddletask.common.util.DateTimeHelper;

public class DeadlineTask extends Task {
    /*** Variables ***/
    private static final String TASK_TYPE = "deadline";
    private LocalDateTime _end;
    private LocalDateTime _reminder;
    private boolean _isRecurring;
    private RECUR_TYPE _recurPeriod;
    
    /*** Constructors ***/
    public DeadlineTask() {
        super();
    }
    
    public DeadlineTask(String description, LocalDateTime end, LocalDateTime reminder, int priority, boolean isRecurring, RECUR_TYPE recurPeriod) {
        super(description, priority, TASK_TYPE);
        this._end = end;
        this._reminder = reminder;
        this._isRecurring = isRecurring;
        this._recurPeriod = recurPeriod;
    }
    
    public DeadlineTask(int taskId, String description, LocalDateTime createdAt, LocalDateTime end, LocalDateTime reminder, boolean isComplete, int priority, boolean isRecurring, RECUR_TYPE recurPeriod) {
        super(taskId, description, createdAt, isComplete, priority, new ArrayList<String>(), TASK_TYPE);
        this._end = end;
        this._reminder = reminder;
        this._isRecurring = isRecurring;
        this._recurPeriod = recurPeriod;
    }
    
    public DeadlineTask(int taskId, String description, LocalDateTime createdAt, LocalDateTime end, LocalDateTime reminder, boolean isComplete, int priority, ArrayList<String> tags, boolean isRecurring, RECUR_TYPE recurPeriod) {
        super(taskId, description, createdAt, isComplete, priority, tags, TASK_TYPE);
        this._end = end;
        this._reminder = reminder;
        this._isRecurring = isRecurring;
        this._recurPeriod = recurPeriod;
    }
    
    /*** Assessors ***/
    public LocalDateTime getEnd() {
        return _end;
    }
    public void setEnd(LocalDateTime end) {
        this._end = end;
    }
    public LocalDateTime getReminder() {
        return _reminder;
    }
    public void setReminder(LocalDateTime reminder) {
        this._reminder = reminder;
    }
    public boolean isRecurring() {
        return _isRecurring;
    }
    public void setRecurring(boolean isRecurring) {
        this._isRecurring = isRecurring;
    }
    public RECUR_TYPE getRecurPeriod() {
        return _recurPeriod;
    }
    public void setRecurPeriod(RECUR_TYPE recurPeriod) {
        this._recurPeriod = recurPeriod;
    }
    
    /*** Methods ***/
```
###### src\main\paddletask\task\entity\FloatingTask.java
``` java
package main.paddletask.task.entity;

import java.time.LocalDateTime;
import java.util.ArrayList;

public class FloatingTask extends Task {
    /*** Variables ***/
    private static final String TASK_TYPE = "floating";
    
    /*** Constructors ***/
    public FloatingTask() {
        super();
    }
    
    public FloatingTask(String description, int priority) {
        super(description, priority, TASK_TYPE);
    }
    
    public FloatingTask(int taskId, String description, LocalDateTime createdAt, boolean isComplete, int priority) {
        super(taskId, description, createdAt, isComplete, priority, new ArrayList<String>(), TASK_TYPE);
    }
    
    public FloatingTask(int taskId, String description, LocalDateTime createdAt, boolean isComplete, int priority, ArrayList<String> tags) {
        super(taskId, description, createdAt, isComplete, priority, tags, TASK_TYPE);
    }
}
```
###### src\main\paddletask\task\entity\Task.java
``` java
package main.paddletask.task.entity;

import java.time.LocalDateTime;
import java.util.ArrayList;

public class Task {
    /*** Variables ***/
    private static ArrayList<Task> _tasks;
    private int _taskId;
    private String _description;
    private LocalDateTime _createdAt;
    private TASK_TYPE _type;
    private boolean _isComplete;
    private int _priority;
    private ArrayList<String> _tags;
    private String[] _details = {"-","-","-","-","-","-","-"};

    public enum TASK_TYPE {
        FLOATING {
            @Override
            public String toString() {
                return "FLOATING";
            }
        },
        TIMED {
            @Override
            public String toString() {
                return "TIMED";
            }
        }, DEADLINE {
            @Override
            public String toString() {
                return "DEADLINE";
            }
        }, ANY {
            @Override
            public String toString() {
                return "ALL";
            }
        };

    };
    
    public enum RECUR_TYPE {
        DAY {
            @Override
            public String toString() {
                return "DAY";
            }
        },
        WEEK {
            @Override
            public String toString() {
                return "WEEK";
            }
        }, 
        MONTH {
            @Override
            public String toString() {
                return "MONTH";
            }
        },
        YEAR {
            @Override
            public String toString() {
                return "YEAR";
            }
        },
        NULL {
            @Override
            public String toString() {
                return "NULL";
            }
        };
    };
    
    /*** Constructors ***/
    public Task() {
        if (_tasks == null) {
            _tasks = new ArrayList<Task>();
        }
    }
    
    public Task(String description, int priority, String type) {
        this._description = description;
        this._createdAt = LocalDateTime.now();
        this._type = determineTaskType(type);
        this._priority = priority;
        this._isComplete = false;
        this._tags = new ArrayList<String>();
    }

    public Task(int taskId, String description, LocalDateTime createdAt, boolean isComplete, int priority, ArrayList<String> tags, String type) {
        this._taskId = taskId;
        this._description = description;
        this._createdAt = createdAt;
        this._isComplete = isComplete;
        this._priority = priority;
        this._tags = tags;
        this._type = determineTaskType(type);
    }
    
    /*** Assessors ***/
    public static ArrayList<Task> getTaskList() {
        return _tasks;
    }
    public static void setTaskList(ArrayList<Task> tasks) {
        Task._tasks = tasks;
    }
    public int getTaskId() {
        return _taskId;
    }
    public void setTaskId(int taskId) {
        this._taskId = taskId;
    }
    public String getDescription() {
        return _description;
    }
    public void setDescription(String description) {
        this._description = description;
    }
    public LocalDateTime getCreatedAt() {
        return _createdAt;
    }
    public void setCreatedAt(LocalDateTime createdAt) {
        this._createdAt = createdAt;
    }
    public TASK_TYPE getType() {
        return _type;
    }
    public void setType(TASK_TYPE type) {
        this._type = type;
    }
    public boolean isComplete() {
        return _isComplete;
    }
    public void setComplete(boolean isComplete) {
        this._isComplete = isComplete;
    }
    public int getPriority() {
        return _priority;
    }
    public void setPriority(int priority) {
        this._priority = priority;
    }
    public ArrayList<String> getTags() {
        return _tags;
    }
    public void setTags(ArrayList<String> tags) {
        this._tags = tags;
    }

    /*** Method ***/
    /**
     * This method gets the task type from a string
     * 
     * @param  typeString  task type in string
     * @return             task type in TASK_TYPE
     */
    public static TASK_TYPE determineTaskType(String typeString) {
        TASK_TYPE type = null;

        if (typeString != null) {
            if (typeString.equalsIgnoreCase("floating")) {
                return TASK_TYPE.FLOATING;
            } else if (typeString.equalsIgnoreCase("timed")) {
                return TASK_TYPE.TIMED;
            } else if (typeString.equalsIgnoreCase("deadline")) {
                return TASK_TYPE.DEADLINE;
            } else if (typeString.equalsIgnoreCase("all")) {
                return TASK_TYPE.ANY;
            }
        }

        return type;
    }
    
    /**
     * This method gets the recurring type from a string
     * 
     * @param  typeString  recurring type in string
     * @return             recurring type in TASK_TYPE
     */
    public static RECUR_TYPE determineRecurType(String typeString) {
        RECUR_TYPE type = null;

        if (typeString != null) {
            if (typeString.equalsIgnoreCase("day")) {
                return RECUR_TYPE.DAY;
            } else if (typeString.equalsIgnoreCase("week")) {
                return RECUR_TYPE.WEEK;
            } else if (typeString.equalsIgnoreCase("month")) {
                return RECUR_TYPE.MONTH;
            } else if (typeString.equalsIgnoreCase("year")) {
                return RECUR_TYPE.YEAR;
            } else if (typeString.equalsIgnoreCase("null")) {
                return RECUR_TYPE.NULL;
            }
        }

        return type;
    }
    
```
###### src\main\paddletask\task\entity\TimedTask.java
``` java
package main.paddletask.task.entity;

import java.time.LocalDateTime;
import java.util.ArrayList;

import main.paddletask.common.util.DateTimeHelper;

public class TimedTask extends Task {
    /*** Variables ***/
    private static final String TASK_TYPE = "timed";
    private LocalDateTime _start;
    private LocalDateTime _end;
    private LocalDateTime _reminder;
    private boolean _isRecurring;
    private RECUR_TYPE _recurPeriod;
    
    /*** Constructors ***/
    public TimedTask() {
        super();
    }
    
    public TimedTask(String description, LocalDateTime start, LocalDateTime end, LocalDateTime reminder, int priority, boolean isRecurring, RECUR_TYPE recurPeriod) {
        super(description, priority, TASK_TYPE);
        this._start = start;
        this._end = end;
        this._reminder = reminder;
        this._isRecurring = isRecurring;
        this._recurPeriod = recurPeriod;
    }
    
    public TimedTask(int taskId, String description, LocalDateTime createdAt, LocalDateTime start, LocalDateTime end, LocalDateTime reminder, boolean isComplete, int priority, boolean isRecurring, RECUR_TYPE recurPeriod) {
        super(taskId, description, createdAt, isComplete, priority, new ArrayList<String>(), TASK_TYPE);
        this._start = start;
        this._end = end;
        this._reminder = reminder;
        this._isRecurring = isRecurring;
        this._recurPeriod = recurPeriod;
    }
    
    public TimedTask(int taskId, String description, LocalDateTime createdAt, LocalDateTime start, LocalDateTime end, LocalDateTime reminder, boolean isComplete, int priority, ArrayList<String> tags, boolean isRecurring, RECUR_TYPE recurPeriod) {
        super(taskId, description, createdAt, isComplete, priority, tags, TASK_TYPE);
        this._start = start;
        this._end = end;
        this._reminder = reminder;
        this._isRecurring = isRecurring;
        this._recurPeriod = recurPeriod;
    }
    
    /*** Assessors ***/
    public LocalDateTime getStart() {
        return _start;
    }
    public void setStart(LocalDateTime start) {
        this._start = start;
    }
    public LocalDateTime getEnd() {
        return _end;
    }
    public void setEnd(LocalDateTime end) {
        this._end = end;
    }
    public LocalDateTime getReminder() {
        return _reminder;
    }
    public void setReminder(LocalDateTime reminder) {
        this._reminder = reminder;
    }
    public boolean isRecurring() {
        return _isRecurring;
    }
    public void setRecurring(boolean recurring) {
        this._isRecurring = recurring;
    }
    public RECUR_TYPE getRecurPeriod() {
        return _recurPeriod;
    }
    public void setRecurPeriod(RECUR_TYPE recurPeriod) {
        this._recurPeriod = recurPeriod;
    }
    
    /*** Method ***/
```
###### src\test\cases\TestStorageController.java
``` java
package test.cases;

import static org.junit.Assert.*;

import java.io.File;
import java.lang.reflect.Method;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.w3c.dom.Document;

import main.paddletask.storage.api.StorageController;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.FloatingTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.Task.RECUR_TYPE;
import main.paddletask.task.entity.TimedTask;

public class TestStorageController {
    /*** Variables ***/
    protected static final String FILE_NAME = "task.xml";
    StorageController sdParser;
    ArrayList<Task> testTaskList;
    
    /*** Setup and Teardown ***/
    @Before
    public void setUp() throws Exception {
        sdParser = StorageController.getInstance();
    }

    @After
    public void tearDown() throws Exception {
    }

    public ArrayList<Task> repopulateTask() {
        // Populate sample arraylist
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        Task task;
        task = new DeadlineTask(1, "Complete CS2103 CE2", LocalDateTime.parse("2015-09-01 12:30", formatter), LocalDateTime.parse("2015-09-10 12:30", formatter), LocalDateTime.parse("2015-09-10 12:25", formatter), true, 1, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        task = new TimedTask(2, "Appointment with dentist", LocalDateTime.parse("2015-09-02 16:34", formatter), LocalDateTime.parse("2015-09-10 14:30", formatter), LocalDateTime.parse("2015-09-10 15:30", formatter), LocalDateTime.parse("2015-09-10 15:25", formatter), false, 2, new ArrayList<String>(), true, RECUR_TYPE.YEAR);
        testTaskList.add(task);
        task = new FloatingTask(3, "Buy groceries", LocalDateTime.parse("2015-09-05 13:03", formatter), true, 3, new ArrayList<String>());
        testTaskList.add(task);
        task = new DeadlineTask(4, "Submit CS2106 Lab 3", LocalDateTime.parse("2015-09-06 22:16", formatter), LocalDateTime.parse("2015-09-10 23:59", formatter), LocalDateTime.parse("2015-09-10 23:54", formatter), false, 3, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        task = new TimedTask(5, "Go out gai gai", LocalDateTime.parse("2015-09-07 23:00", formatter), LocalDateTime.parse("2015-09-17 13:00", formatter), LocalDateTime.parse("2015-09-17 17:00", formatter), LocalDateTime.parse("2015-09-17 16:55", formatter), true, 2, new ArrayList<String>(), true, RECUR_TYPE.WEEK);
        testTaskList.add(task);
        task = new FloatingTask(6, "Eat more Vitamin C", LocalDateTime.parse("2015-09-07 23:01", formatter), false, 1, new ArrayList<String>());
        testTaskList.add(task);
        task = new DeadlineTask(7, "Pay money for steamboat", LocalDateTime.parse("2015-09-08 08:55", formatter), LocalDateTime.parse("2015-09-10 23:59", formatter), LocalDateTime.parse("2015-09-10 23:54", formatter), false, 2, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        task = new TimedTask(8, "Walk the neighbor's dog", LocalDateTime.parse("2015-09-08 10:20", formatter), LocalDateTime.parse("2015-09-13 17:00", formatter), LocalDateTime.parse("2015-09-13 18:00", formatter), LocalDateTime.parse("2015-09-13 17:55", formatter), true, 1, new ArrayList<String>(), false, RECUR_TYPE.DAY);
        testTaskList.add(task);
        task = new FloatingTask(9, "Stock up locker with maggimee", LocalDateTime.parse("2015-09-10 11:45", formatter), true, 3, new ArrayList<String>());
        testTaskList.add(task);
        task = new DeadlineTask(10, "Sign up for linux workshop", LocalDateTime.parse("2015-09-14 21:10", formatter), LocalDateTime.parse("2015-09-20 23:59", formatter), LocalDateTime.parse("2015-09-20 23:54", formatter), false, 3, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        
        Document doc = sdParser.parseTask(testTaskList);
        sdParser.writeXml(doc);
        
        return testTaskList;
    }
    
    /*** Test Cases 
     * @throws Exception  ***/
    @Test
    public void testSetDirectory() throws Exception {
        
        Method m = sdParser.getClass().getDeclaredMethod("setDirectory", String.class);
        m.setAccessible(true);
        boolean success = (boolean)m.invoke(sdParser, "C:\\Users\\Juliana\\Desktop\\paddletasktest.xml");
        if (success) {
            assert true;
        } else {
            assert false;
        }
        
        m = sdParser.getClass().getDeclaredMethod("setDirectory", String.class);
        m.setAccessible(true);
        success = (boolean)m.invoke(sdParser, "task.xml");
        if (success) {
            assert true;
        } else {
            assert false;
        }
        
        File file = new File("C:\\paddletasktest.xml");
        file.delete();
    }
    
    @Test
    public void testGetXmlFile() throws Exception {
    	Method m = sdParser.getClass().getDeclaredMethod("getXmlFile", String.class);
		m.setAccessible(true);
        File file = (File)m.invoke(sdParser, FILE_NAME);
        if (file.exists()) {
            assert true;
        } else {
            assert false;
        }
        
        file = new File(FILE_NAME);
        file.delete();
        m = sdParser.getClass().getDeclaredMethod("getXmlFile", String.class);
        m.setAccessible(true);
        file = (File)m.invoke(sdParser, FILE_NAME);
        if (file.exists()) {
            assert true;
        } else {
            assert false;
        }
    }

    @Test
    public void testReadTask() {
        testTaskList = new ArrayList<Task>();
        ArrayList<Task> taskList = sdParser.readTask();
        if (taskList != null) {
            assert true;
        } else {
            assert false;
        }
        if (taskList.size() == 0) {
            assert true;
        } else {
            assert false;
        }
        
        testTaskList = repopulateTask();
        taskList = sdParser.readTask();
        if (taskList.size() > 0) {
            assert true;
        } else {
            assert false;
        }
    }
    
    @Test
    public void testParseTask() {
        testTaskList = new ArrayList<Task>();
        Document doc = sdParser.parseTask(testTaskList);
        if (doc != null) {
            assert true;
        } else {
            assert false;
        }
        if (doc.getElementsByTagName("item").getLength() == 0) {
            assert true;
        } else {
            assert false;
        }
        
        testTaskList = repopulateTask();
        doc = sdParser.parseTask(testTaskList);
        if (doc.getDocumentElement().getNodeName().equals("task")) {
            assert true;
        } else {
            assert false;
        }
        if (doc.getElementsByTagName("item").getLength() == 10) {
            assert true;
        } else {
            assert false;
        }
    }
    
    @Test
    public void testParseXml() throws Exception {
        Method m = sdParser.getClass().getDeclaredMethod("parseXml");
        m.setAccessible(true);
        Document doc = (Document)m.invoke(sdParser);
        if (doc != null) {
            assert true;
        } else {
            assert false;
        }
        if (doc.getDocumentElement().getNodeName().equals("task")) {
            assert true;
        } else {
            assert false;
        }
    }
    
    @Test
    public void testWriteXml() {
        testTaskList = new ArrayList<Task>();
        Document doc = sdParser.parseTask(testTaskList);
        boolean result = sdParser.writeXml(doc);
        assertEquals(true, result);
        
        testTaskList = repopulateTask();
        doc = sdParser.parseTask(testTaskList);
        result = sdParser.writeXml(doc);
        assertEquals(true, result);
    }
}
```
###### src\test\cases\TestTaskController.java
``` java
package test.cases;

import static org.junit.Assert.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.w3c.dom.Document;

import main.paddletask.storage.api.StorageController;
import main.paddletask.task.api.TaskController;
import main.paddletask.task.entity.DeadlineTask;
import main.paddletask.task.entity.FloatingTask;
import main.paddletask.task.entity.Task;
import main.paddletask.task.entity.TimedTask;
import main.paddletask.task.entity.Task.RECUR_TYPE;
import main.paddletask.task.entity.Task.TASK_TYPE;

public class TestTaskController {
    /*** Variables ***/
    protected static final String FILE_NAME = "task.xml";
    StorageController sController;
    ArrayList<Task> testTaskList;
    TaskController tController;
    
    /*** Setup and Teardown ***/
    @Before
    public void setUp() throws Exception {
        sController = StorageController.getInstance();
        testTaskList = repopulateTask();
        tController = TaskController.getInstance();
    }

    @After
    public void tearDown() throws Exception {
    }
    
    public ArrayList<Task> repopulateTask() {
        ArrayList<Task> testTaskList = new ArrayList<Task>();
        
        // Populate sample arraylist
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        Task task;
        task = new DeadlineTask(1, "Complete CS2103 CE2", LocalDateTime.parse("2015-09-01 12:30", formatter), LocalDateTime.parse("2015-09-10 12:30", formatter), LocalDateTime.parse("2015-09-10 12:25", formatter), true, 1, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        task = new TimedTask(2, "Appointment with dentist", LocalDateTime.parse("2015-09-02 16:34", formatter), LocalDateTime.parse("2015-09-10 14:30", formatter), LocalDateTime.parse("2015-09-10 15:30", formatter), LocalDateTime.parse("2015-09-10 15:25", formatter), false, 2, new ArrayList<String>(), true, RECUR_TYPE.YEAR);
        testTaskList.add(task);
        task = new FloatingTask(3, "Buy groceries", LocalDateTime.parse("2015-09-05 13:03", formatter), true, 3, new ArrayList<String>());
        testTaskList.add(task);
        task = new DeadlineTask(4, "Submit CS2106 Lab 3", LocalDateTime.parse("2015-09-06 22:16", formatter), LocalDateTime.parse("2015-09-10 23:59", formatter), LocalDateTime.parse("2015-09-10 23:54", formatter), false, 3, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        task = new TimedTask(5, "Go out gai gai", LocalDateTime.parse("2015-09-07 23:00", formatter), LocalDateTime.parse("2015-09-17 13:00", formatter), LocalDateTime.parse("2015-09-17 17:00", formatter), LocalDateTime.parse("2015-09-17 16:55", formatter), true, 2, new ArrayList<String>(), true, RECUR_TYPE.WEEK);
        testTaskList.add(task);
        task = new FloatingTask(6, "Eat more Vitamin C", LocalDateTime.parse("2015-09-07 23:01", formatter), false, 1, new ArrayList<String>());
        testTaskList.add(task);
        task = new DeadlineTask(7, "Pay money for steamboat", LocalDateTime.parse("2015-09-08 08:55", formatter), LocalDateTime.parse("2015-09-10 23:59", formatter), LocalDateTime.parse("2015-09-10 23:54", formatter), false, 2, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        task = new TimedTask(8, "Walk the neighbor's dog", LocalDateTime.parse("2015-09-08 10:20", formatter), LocalDateTime.parse("2015-09-13 17:00", formatter), LocalDateTime.parse("2015-09-13 18:00", formatter), LocalDateTime.parse("2015-09-13 17:55", formatter), true, 1, new ArrayList<String>(), false, RECUR_TYPE.DAY);
        testTaskList.add(task);
        task = new FloatingTask(9, "Stock up locker with maggimee", LocalDateTime.parse("2015-09-10 11:45", formatter), true, 3, new ArrayList<String>());
        testTaskList.add(task);
        task = new DeadlineTask(10, "Sign up for linux workshop", LocalDateTime.parse("2015-09-14 21:10", formatter), LocalDateTime.parse("2015-09-20 23:59", formatter), LocalDateTime.parse("2015-09-20 23:54", formatter), false, 3, new ArrayList<String>(), false, RECUR_TYPE.NULL);
        testTaskList.add(task);
        
        Document doc = sController.parseTask(testTaskList);
        sController.writeXml(doc);
        
        return testTaskList;
    }

    /*** Test Cases ***/
    @Test
    public void testAddTask() {
        // Test first add
        File file = new File(FILE_NAME);
        if (file.exists()) {
            System.gc();
            try {
                Files.delete(file.toPath());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        Task.setTaskList(new ArrayList<Task>());
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        Task task = new DeadlineTask("My first task", LocalDateTime.parse("2015-09-20 12:00", formatter), LocalDateTime.parse("2015-09-20 11:55", formatter), 1, false, RECUR_TYPE.NULL);
        boolean result = tController.addTask(task);
        assertEquals(true, result);
        assertEquals(1, Task.getTaskList().size());
        
        // Set up
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Add DeadlineTask
        formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        task = new DeadlineTask("Stock up rainbow icecream", LocalDateTime.parse("2015-09-20 12:00", formatter), LocalDateTime.parse("2015-09-20 11:55", formatter), 2, false, RECUR_TYPE.NULL);
        result = tController.addTask(task);
        assertEquals(true, result);
        assertEquals(11, Task.getTaskList().size());
        
        // Add TimedTask
        task = new TimedTask("Eat lunch with senpai", LocalDateTime.parse("2015-10-01 12:00", formatter), LocalDateTime.parse("2015-10-01 14:00", formatter), LocalDateTime.parse("2015-10-01 13:55", formatter), 3, false, RECUR_TYPE.NULL);
        result = tController.addTask(task);
        assertEquals(true, result);
        assertEquals(12, Task.getTaskList().size());
        
        // Add TimedTask
        task = new FloatingTask("Rainbows and clouds :3", 1);
        result = tController.addTask(task);
        assertEquals(true, result);
        assertEquals(13, Task.getTaskList().size());
    }
    
    @Test
    public void testGetTask() {
        // Set up
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Perform test
        ArrayList<Task> taskList = tController.getTask();
        assertEquals(testTaskList.size(), taskList.size());
    }
    
    @Test
    public void testGetTaskString() {
        // Set up
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Get DeadlineTask
        ArrayList<Task> filteredTaskList = tController.getTask(TASK_TYPE.DEADLINE);
        assertEquals(4, filteredTaskList.size());
        
        // Get TimedTask
        filteredTaskList = tController.getTask(TASK_TYPE.TIMED);
        assertEquals(3, filteredTaskList.size());
        
        // Get FloatingTask
        filteredTaskList = tController.getTask(TASK_TYPE.FLOATING);
        assertEquals(3, filteredTaskList.size());
        
    }
    
    @Test
    public void testGetTaskInt() {
        // Set up
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Get DeadlineTask
        Task task = tController.getTask(5);
        assertEquals(5, task.getTaskId());
        
        // Get null
        task = tController.getTask(100);
        assertEquals(null, task);
        
    }
    
    @Test
    public void testUpdateTask() {
        // Set up
        ArrayList<Task> updatedTaskList = new ArrayList<Task>();
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Perform update
        Task task = testTaskList.get(5);
        task.setDescription("Submit CS2106 Lab is cancelled lol");
        tController.updateTask(task);
        
        // Check
        updatedTaskList = tController.getTask();
        assertEquals(task.getTaskId(), updatedTaskList.get(5).getTaskId());
        assertEquals("Submit CS2106 Lab is cancelled lol", updatedTaskList.get(5).getDescription());
    }
    
    @Test
    public void testDeleteTask() {
        // Set up
        ArrayList<Task> updatedTaskList = new ArrayList<Task>();
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Perform update
        tController.deleteTask(3);
        
        // Check
        updatedTaskList = tController.getTask();
        assertEquals(9, updatedTaskList.size());
    }
    
    @Test
    public void testCompleteTask() {
        // Set up
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Perform update
        tController.completeTask(4);
        
        // Check
        Task task = tController.getTask(4);
        assertEquals(true, ((DeadlineTask) task).isComplete());
    }
    
    @Test
    public void testWriteAllToFile() {
        // Set up
        ArrayList<Task> updatedTaskList = new ArrayList<Task>();
        testTaskList = repopulateTask();
        Task.setTaskList(testTaskList);
        
        // Perform update
        tController.writeAllToFile(testTaskList);
        
        // Check
        updatedTaskList = tController.getTask();
        assertEquals(10, updatedTaskList.size());
    }
    
    @Test
    public void testGetAvailableTaskId() {
        // Set up
        testTaskList = new ArrayList<Task>();
        Task.setTaskList(testTaskList);
        tController.writeAllToFile(testTaskList);
        
        // Perform test
        int result = tController.getAvailableTaskId();
        assertEquals(1, result);
        
        // Set up
        testTaskList = repopulateTask();
        tController.writeAllToFile(testTaskList);
        
        // Perform test
        result = tController.getAvailableTaskId();
        assertEquals(testTaskList.size() + 1, result);
    }
}
```
