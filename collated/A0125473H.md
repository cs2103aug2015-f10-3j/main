# A0125473H
###### src\main\paddletask\command\api\AddTaskCommand.java
``` java
package main.paddletask.command.api;

import java.time.LocalDateTime;
import java.util.ArrayList;

import main.paddletask.common.data.ParserConstants;
import main.paddletask.common.exception.TaskAddFailedException;
import main.paddletask.common.util.DateTimeHelper;
import main.paddletask.task.api.*;
import main.paddletask.task.entity.*;
import main.paddletask.task.entity.Task.RECUR_TYPE;

public class AddTaskCommand extends Command implements ParserConstants {
	/*** Variables ***/
	private ArrayList<Task> _taskList = new ArrayList<Task>();
	private TaskController _taskController = TaskController.getInstance();
	//stored to keep track of the created user task, supporting undo of function
	private Task _userTask = null;

	private static final int DEFAULT_PRIORITY = 3;
	private static final int FIVE_MINUTES_BEFORE = -5;

	/*** Methods ***/
    /**
     * This method adds a new Task based on user input for the add command
     * 
     * @return an ArrayList of Task objects that contains the new Task
     *         object
     * @throws TaskAddFailedException 
     */
	@Override
	public ArrayList<Task> execute() throws TaskAddFailedException {
		try {
			assert(_taskList != null);
			clearResult();
			_userTask = createNewTask();
			storeNewTask();
			appendToResult();
			return _taskList;
		} catch (TaskAddFailedException e) {
			throw e;
		} catch (Exception e) {
			throw new TaskAddFailedException("Adding of task was unsuccessful");
		}
	}
	
	/**
     * This method is invoked to clear the
     * Arraylist of tasks used by execute
     */
	private void clearResult() {
		_taskList.clear();
	}
	
	/**
     * @return       <code>Task</code> if the task is successfully created;
     *               <code>Null</code> otherwise.
	 * @throws TaskAddFailedException 
     */
	private Task createNewTask() throws TaskAddFailedException {
		assert(hasOption(OPTIONS.ADD.toString()));
		Task userTask = createTaskByType();
		return userTask;
	}

	/**
     * This method is invoked to create a Task object
     * based on the type specified by the user
     * 
     * @return       <code>Task</code> if the task is successfully created;
     *               <code>Null</code> otherwise.
	 * @throws TaskAddFailedException 
     */
	private Task createTaskByType() throws TaskAddFailedException {
		if (hasOption(OPTIONS.BY.toString())) {
			return createDeadlineTask();
		} else if (hasOption(OPTIONS.BETWEEN.toString()) && hasOption(OPTIONS.AND.toString())) {
			return createTimedTask();
		} else {
			return createFloatingTask();
		}
	}

	/**
     * @return       <code>Task</code> if the task is successfully created;
     *               <code>Null</code> otherwise.
     */
	private Task createDeadlineTask() {
		String description = getTaskDescription();
		Integer priority = getTaskPriority();
		LocalDateTime deadline = getTaskDeadline();
		LocalDateTime reminder = calculateTaskReminderDate(deadline);
		boolean recurring = isTaskRecurring();
		RECUR_TYPE recurType = getTaskRecurrenceType(recurring);
		return new DeadlineTask(description, deadline, reminder, priority, recurring, recurType);
		
	}

	/**
     * @return       <code>Task</code> if the task is successfully created;
     *               <code>Null</code> otherwise.
	 * @throws TaskAddFailedException 
     */
	private Task createTimedTask() throws TaskAddFailedException {
		String description = getTaskDescription();
		Integer priority = getTaskPriority();
		LocalDateTime startDate = getTaskStartDate();
		LocalDateTime deadline = getTaskEndDate();
		if (DateTimeHelper.isLater(startDate, deadline)) {
			throw new TaskAddFailedException("Start date is later than end date");
		}
		LocalDateTime reminder = calculateTaskReminderDate(deadline);
		boolean recurring = isTaskRecurring();
		RECUR_TYPE recurType = getTaskRecurrenceType(recurring);
		return new TimedTask(description, startDate, deadline, reminder, priority, recurring, recurType);
	}

	/**
     * @return       <code>Task</code> if the task is successfully created;
     *               <code>Null</code> otherwise.
     */
	private Task createFloatingTask() {
		String description = getTaskDescription();
		Integer priority = getTaskPriority();
		return new FloatingTask(description, priority);
	}

	/**
     * @return       <code>Task</code> if the task is successfully created;
     *               <code>Null</code> otherwise.
     */
	private String getTaskDescription() {
		return getOption(OPTIONS.ADD.toString()).getStringValue();
	}

	/**
     * @return       <code>int priority</code> if the priority option exists;
     *               <code>DEFAULT_PRIORITY</code> otherwise.
     */
	private Integer getTaskPriority() {
		if (hasOption(OPTIONS.PRIORITY.toString())) {
			return getOption(OPTIONS.PRIORITY.toString()).getIntegerValue();
		} else {
			return DEFAULT_PRIORITY;
		}
	}

	/**
     * @return LocalDateTime representing the start date
     */
	private LocalDateTime getTaskStartDate() {
		return getOption(OPTIONS.BETWEEN.toString()).getDateValue();
	}

	/**
     * @return LocalDateTime representing the end date
     */
	private LocalDateTime getTaskEndDate() {
		return getOption(OPTIONS.AND.toString()).getDateValue();
	}

	/**
     * @return LocalDateTime representing the end date
     */
	private LocalDateTime getTaskDeadline() {
		return getOption(OPTIONS.BY.toString()).getDateValue();
	}

	/**
     * This method is invoked to calculate the default reminder time from
     * deadline
     * 
     * @param  LocalDateTime  deadline of the task
     * @return       <code>LocalDateTime</code> if date was specified by user input;
     *               <code>Deadline - 5 minutes</code> otherwise.
     */
	private LocalDateTime calculateTaskReminderDate(LocalDateTime deadline) {
		if (hasOption(OPTIONS.REMIND.toString())) {
			return getOption(OPTIONS.REMIND.toString()).getDateValue();
		} else {
			return DateTimeHelper.addMinutes(deadline, FIVE_MINUTES_BEFORE);
		}
	}

	/**
     * @return       <code>true</code> if the task is recurring;
     *               <code>false</code> otherwise.
     */
	private boolean isTaskRecurring() {
		return hasOption(OPTIONS.REPEAT.toString());
	}

	/**
     * This method is invoked to retrieve the recurrence type of the task
     * 
     * @param  boolean  recurring
     * @return       <code>RECUR_TYPE.*</code> if the task is recurring;
     *               <code>RECUR_TYPE.NULL</code> otherwise.
     */
	private RECUR_TYPE getTaskRecurrenceType(boolean recurring) {
		if (recurring) {
			String recurranceType = getOption(OPTIONS.REPEAT.toString()).getStringValue();
			return Task.determineRecurType(recurranceType);
		}
		return Task.RECUR_TYPE.NULL;
	}

	private void appendToResult() {
		_taskList.add(_userTask);
	}

	/**
     * This method adds the Task object to file
     */
	private void storeNewTask() {
		_taskController.addTask(_userTask);
	}

	/**
     * This method is invoked to undo changes made by execute()
     * 
     * @return an ArrayList of Task objects that contains the new Task
     *         object
     */
	@Override
	public ArrayList<Task> undo() {
		assert(_userTask != null);
		deleteTask();
		clearResult();
		appendToResult();
		return _taskList;
	}
	
	private void deleteTask() {
		int taskID = _userTask.getTaskId();
		_taskController.deleteTask(taskID);
	}
}
```
###### src\main\paddletask\command\api\ClearCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;

import main.paddletask.task.entity.Task;

public class ClearCommand extends Command {

	/*** Methods ***/
	@Override
	public ArrayList<Task> execute() {
		clearScreen();
		return null;
	}
	
	public void clearScreen() {
		//set observable state as changed
		setChanged();
		//notify the observer - screen
		notifyObservers(null);
	}

```
###### src\main\paddletask\command\api\Command.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Observable;
import java.util.Stack;

import main.paddletask.command.data.Option;
import main.paddletask.task.entity.Task;

public abstract class Command extends Observable {

	/*** Variables ***/
	private static Stack<Command> _commandList;
	private static Stack<Command> _undoCommandList;
	private HashMap<String, Option> _options = new HashMap<String, Option>();

	/*** Constructor ***/
	public Command() {
		createCommandHistories();
		assert(_options != null);
	}

	private void createCommandHistories() {
		if (_commandList == null || _undoCommandList == null) {
			_commandList = new Stack<Command>();
			_undoCommandList = new Stack<Command>();
		}
	}

	/*** Methods mainly for Option manipulation ***/
	/**
	 * This method is invoked to check if a specific option exists
	 * for the command
	 * 
	 * @return <code>true</code> if option exists
	 * 		   <code>false</code> otherwise
	 */
	public boolean hasOption(String optionName) {
		return _options.containsKey(optionName);
	}

	/**
	 * This method is invoked to get a specific option if it exists
	 * for the command
	 * 
	 * @return <code>Option</code> if option exists
	 * 		   <code>NULL</code> otherwise
	 */
	public Option getOption(String optionName) {
		if (hasOption(optionName)) {
			return _options.get(optionName);
		} else {
			return null;
		}
	}

	/**
	 * This method is invoked to add a specific option 
	 * for the command
	 * 
	 * @return <code>true</code> if option was successfully added
	 * 		   <code>false</code> otherwise
	 */
	public boolean addOption(String optionName, Option option) {
		if (_options.put(optionName, option) != null) {
			return false;
		} else {
			return true;
		}
	}

	/*** Accessor methods ***/
	public Option[] getOptions() {
		return _options.values().toArray(new Option[_options.size()]);
	}

	public void setOption(HashMap<String, Option> options) {
		this._options = options;
	}
	public static Stack<Command> getCommandList() {
		return _commandList;
	}

	public static void setCommandList(Stack<Command> commandList) {
		Command._commandList = commandList;
	}

	public static Stack<Command> getUndoCommandList() {
		return _undoCommandList;
	}

	public static void setUndoCommandList(Stack<Command> undoCommandList) {
		Command._undoCommandList = undoCommandList;
	}

	//All subclasses are forced to implement execute and undo
	public abstract ArrayList<Task> execute() throws Exception;

	public abstract ArrayList<Task> undo() throws Exception;
}
```
###### src\main\paddletask\command\api\RedoCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;
import java.util.Stack;

import main.paddletask.common.exception.InvalidRedoException;
import main.paddletask.task.entity.Task;

public class RedoCommand extends Command {

	@Override
	public ArrayList<Task> execute() throws Exception {
		Stack<Command> undoCommandList = getUndoCommandList();
		assert(undoCommandList != null);
		if (isRedoable(undoCommandList)) {
			throw new InvalidRedoException("Unable to redo further");
		}
		Command previousCommand = getPreviousCommand(undoCommandList);
		//add previously undone command back into the list of done commands
		addTo(getCommandList(), previousCommand);
		return previousCommand.execute();
	}
	
	private void addTo(Stack<Command> commandList, Command command) {
		commandList.add(command);
	}
	
	private boolean isRedoable(Stack<Command> undoCommandList) {
		return undoCommandList.size() < 1;
	}
	
	private Command getPreviousCommand(Stack<Command> undoCommandList) {
		return undoCommandList.pop();
	}

	@Override
	public ArrayList<Task> undo() {
		return null;
	}

}
```
###### src\main\paddletask\command\api\UndoCommand.java
``` java
package main.paddletask.command.api;

import java.util.ArrayList;
import java.util.Stack;

import main.paddletask.common.exception.InvalidUndoException;
import main.paddletask.task.entity.Task;

public class UndoCommand extends Command {

	@Override
	public ArrayList<Task> execute() throws Exception {
		Stack<Command> commandList = getCommandList();
		assert(commandList != null);
		if (isUndoable(commandList)) {
			throw new InvalidUndoException("Unable to undo further");
		}
		Command previousCommand = getPreviousCommand(commandList);
		//add previously done command into the list of undone commands
		addTo(getUndoCommandList(), previousCommand);
		return previousCommand.undo();
	}

	private void addTo(Stack<Command> commandList, Command command) {
		commandList.add(command);
	}

	private boolean isUndoable(Stack<Command> commandList) {
		return commandList.size() < 1;
	}

	private Command getPreviousCommand(Stack<Command> commandList) {
		return commandList.pop();
	}

	@Override
	public ArrayList<Task> undo() {
		return null;
	}
}
```
###### src\main\paddletask\command\data\Option.java
``` java
package main.paddletask.command.data;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class Option {
	
	private static final String INVALID_STRING = "";
	private static final int INVALID_INT_VALUE = -1;
	private List<Object> _values = new ArrayList<Object>();
	
	/*** Methods ***/
	public LocalDateTime getDateValue() {
		return getDateValue(0);
	}
	
	public String getStringValue() {
		return getStringValue(0);
	}
	
	public int getIntegerValue() {
		return getIntegerValue(0);
	}
	
	public LocalDateTime getDateValue(int position) {
		try {
			return (LocalDateTime)getValue(position);
		} catch (ClassCastException e) {
			return null;
		}
	}
	
	public String getStringValue(int position) {
		try {
			return (String)getValue(position);
		} catch (ClassCastException e) {
			return INVALID_STRING;
		}
	}
	
	public int getIntegerValue(int position) {
		try {
			return (Integer)getValue(position);
		} catch (ClassCastException e) {
			return INVALID_INT_VALUE;
		}
	}
	
	public Object getValue() {
		return getValue(0);
	}
	
	public Object getValue(int position) {
		if (!hasValues()) {
			return null;
		}
		try {
			return _values.get(position);
		} catch (IndexOutOfBoundsException e) {
			return null;
		}
	}
	
	// this function throws exception because it is called during
	// the creation of a command. The exception will tell the 
	// parser that whatever it is currently doing is invalid
	public boolean addValues(Object[] values) throws Exception {
		boolean success = false;
		for (Object value : values) {
			success |= this._values.add(value);
		}
		return success;
	}
	
	public boolean addValue(Object value) throws Exception {
		return _values.add(value);
	}
	
	public boolean hasValues() {
		return !_values.isEmpty();
	}
	
	public int getValuesCount() {
		return _values.size();
	}
}
```
###### src\main\paddletask\common\data\ParserConstants.java
``` java
package main.paddletask.common.data;
public interface ParserConstants {

	/*** Main command enums ***/
	public static enum COMMAND_TYPE {
		ADD, VIEW, EDIT, DELETE, 
		COMPLETE, SEARCH, UNDO, REDO, 
		INVALID, EXIT, CLEAR, HELP, SETDIRECTORY,
		MORE, TAG, UNTAG
	}

	public static enum COMMANDS {
		ADD("add"), VIEW("view"), EDIT("edit"), DELETE("delete"), 
		COMPLETE("complete"), SEARCH("search"), UNDO("undo"), 
		REDO("redo"), EXIT("exit"), CLEAR("clear"), HELP("help"),
		SETDIRECTORY("setdirectory"), MORE("more"), TAG("tag"), 
		UNTAG("untag"),

		ADD_SHORT("/a"), VIEW_SHORT("/v"), EDIT_SHORT("/e"), DELETE_SHORT("/d"), 
		COMPLETE_SHORT("/c"), SEARCH_SHORT("/s"), UNDO_SHORT("/u"), 
		REDO_SHORT("/r"), EXIT_SHORT("/ex"), CLEAR_SHORT("/cl"), HELP_SHORT("/h"),
		SETDIRECTORY_SHORT("/sd"), MORE_SHORT("/m"), TAG_SHORT("/t"), UNTAG_SHORT("/ut");

		private final String commandText;
		
		private COMMANDS(final String commandText) {
			this.commandText = commandText;
		}

		@Override
		public String toString() {
			return commandText;
		}
	}

	/*** Sub command enums ***/
	public static enum OPTIONS {
		ADD("add"), VIEW("view"), EDIT("edit"), DELETE("delete"), 
		COMPLETE("complete"), SEARCH("search"), BY("by"), UNDO("undo"), 
		REDO("redo"), REMIND("remind"), CLEAR("clear"), EXIT("exit"), 
		BETWEEN("between"), AND("and"), DESC("desc"), STARTDATE("sdate"), 
		STARTTIME("stime"), ENDDATE("edate"), ENDTIME("etime"),
		ALL("all"), TODAY("today"), TOMORROW("tomorrow"), WEEK("week"), 
		MONTH("month"), HELP("help"), SETDIRECTORY("setdirectory"), MORE("more"),
		TAG("tag"), UNTAG("untag"), PRIORITY("priority"), REPEAT("repeat"),
		
		ADD_SHORT("/a"), VIEW_SHORT("/v"), EDIT_SHORT("/e"), DELETE_SHORT("/d"), 
		COMPLETE_SHORT("/c"), SEARCH_SHORT("/s"), BY_SHORT("-b"), UNDO_SHORT("/u"), 
		REDO_SHORT("/r"), REMIND_SHORT("-r"), CLEAR_SHORT("/cl"), EXIT_SHORT("/ex"), 
		BETWEEN_SHORT("-bt"), AND_SHORT("-a"), DESC_SHORT("-d"), STARTDATE_SHORT("-sD"), 
		STARTTIME_SHORT("-sT"), ENDDATE_SHORT("-eD"), ENDTIME_SHORT("-eT"), 
		ALL_SHORT("-a"), VIEW_COMPLETE_SHORT("-c"), TODAY_SHORT("-td"), TOMORROW_SHORT("-tm"), WEEK_SHORT("-w"), 
		MONTH_SHORT("-m"), HELP_SHORT("/h"), SETDIRECTORY_SHORT("/sd"), MORE_SHORT("/m"),
		TAG_SHORT("/t"), UNTAG_SHORT("/ut"), PRIORITY_SHORT("-p"), HASHTAG("#"), REPEAT_SHORT("-re");

		private final String optionText;
		
		private OPTIONS(final String commandText) {
			this.optionText = commandText;
		}

		@Override
		public String toString() {
			return optionText;
		}
	}
	
	/*** Helper enums ***/
	public static enum DAY {
		DAY("daily"), MONTH("monthly"), WEEK("weekly"), YEAR("yearly");

		private final String commandText;
		
		private DAY(final String commandText) {
			this.commandText = commandText;
		}

		@Override
		public String toString() {
			return commandText;
		}
	}
	
	public static enum TYPE {
		STRING, STRING_ARRAY, INTEGER, INTEGER_ARRAY, DATE,
		STRING_OPT, STRING_ARRAY_OPT, INTEGER_OPT, INTEGER_ARRAY_OPT,
		DATE_OPT, DAY, NONE;
	}

	/*** used for suggestions ***/
	public static enum ADD_OPTIONS {
		BY("by"), REMIND("remind"), BETWEEN("between"), AND("and"), 
		PRIORITY("priority"), EVERY("every"),
		
		BY_SHORT("-b"), REMIND_SHORT("-r"), BETWEEN_SHORT("-bt"), AND_SHORT("-a"), 
		PRIORITY_SHORT("-p"), EVERY_SHORT("-re");

		private final String commandText;
		
		private ADD_OPTIONS(final String commandText) {
			this.commandText = commandText;
		}

		@Override
		public String toString() {
			return commandText;
		}
	}
	
	public static enum VIEW_OPTIONS {
		COMPLETE("complete"), ALL("all"), TODAY("today"), TOMORROW("tomorrow"), WEEK("week"), 
		MONTH("month"), 
		
		COMPLETE_SHORT("-c"), ALL_SHORT("-a"), TODAY_SHORT("-tD"), TOMORROW_SHORT("-tM"), WEEK_SHORT("-w"), 
		MONTH_SHORT("-m");

		private final String commandText;
		
		private VIEW_OPTIONS(final String commandText) {
			this.commandText = commandText;
		}

		@Override
		public String toString() {
			return commandText;
		}
	}
	
	public static enum EDIT_OPTIONS {
		REMIND("remind"), STARTDATE("sdate"), STARTTIME("stime"), DESC("desc"),
		ENDDATE("edate"), ENDTIME("etime"), PRIORITY("priority"), REPEAT("repeat"),
		
		REMIND_SHORT("-r"), DESC_SHORT("-d"), STARTDATE_SHORT("-sD"), 
		STARTTIME_SHORT("-sT"), ENDDATE_SHORT("-eD"), ENDTIME_SHORT("-eT"), 
		PRIORITY_SHORT("-p"), REPEAT_SHORT("-re");

		private final String commandText;
		
		private EDIT_OPTIONS(final String commandText) {
			this.commandText = commandText;
		}

		@Override
		public String toString() {
			return commandText;
		}
	}
	
	public static enum TAGUNTAG_OPTIONS {
		HASHTAG("#");

		private final String commandText;
		
		private TAGUNTAG_OPTIONS(final String commandText) {
			this.commandText = commandText;
		}

		@Override
		public String toString() {
			return commandText;
		}
	}
}
```
###### src\main\paddletask\common\util\DateTimeHelper.java
``` java
package main.paddletask.common.util;

import java.time.DateTimeException;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Date;

public class DateTimeHelper {
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
	private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy");
	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final String TIME_PADDING = " 00:00";
	
	/*** Methods ***/
	// parses string exclusively in this format "dd/mm/yyyy HH:mm"
	public static LocalDateTime parseStringToDateTime(String inputString) {
		try {
			return LocalDateTime.parse(inputString,DATE_TIME_FORMATTER);
		} catch (DateTimeException e) {
			return null;
		}
	}

	// parses date exclusively in this format "dd/mm/yyyy HH:mm"
	public static String parseDateTimeToString(LocalDateTime inputDateTime) {
		try {
			return inputDateTime.format(DATE_TIME_FORMATTER);
		} catch (DateTimeException e) {
			return null;
		}
	}
	
	public static LocalDateTime setTimezoneForDate(Date date) {
	    return LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
	}

	// Support for retrieval of date and time instead of whole date
	public static String getDate(LocalDateTime inputDateTime) {
		try {
			return inputDateTime.toLocalDate().format(DATE_FORMATTER);
		} catch (DateTimeException e) {
			return null;
		}
	}

	public static String getTime(LocalDateTime inputDateTime) {
		try {
			return inputDateTime.toLocalTime().format(TIME_FORMATTER);
		} catch (DateTimeException e) {
			return null;
		}
	}
	
	public static boolean isLater(LocalDateTime baseline, LocalDateTime than) {
		return baseline.compareTo(than) > 0;
	}
	
	public static boolean isEqual(LocalDateTime baseline, LocalDateTime than) {
	    return baseline.compareTo(than) == 0;
	}
	
	public static String getDayOfWeek(String inputDate) {
		try {
			LocalDateTime date = parseStringToDateTime(inputDate + TIME_PADDING);
			if (date != null) {
				return date.getDayOfWeek().toString();
			}
		} catch (DateTimeException e) {}
		return inputDate;
	}
	
	public static boolean isDate(String date) {
		return date.matches("(\\d{2})/(\\d{2})/(\\d{4})");
	}

	// Date/Time manipulation helper functions
	public static LocalDateTime now() {
		return LocalDateTime.now();
	}

	public static LocalDateTime addYears(LocalDateTime inputDateTime, int yearsToAdd) {
		return inputDateTime.plusYears(yearsToAdd);
	}

	public static LocalDateTime addMonths(LocalDateTime inputDateTime, int monthsToAdd) {
		return inputDateTime.plusMonths(monthsToAdd);
	}
	
	public static LocalDateTime addWeeks(LocalDateTime inputDateTime, int weeksToAdd) {
        return inputDateTime.plusWeeks(weeksToAdd);
    }

	public static LocalDateTime addDays(LocalDateTime inputDateTime, int daysToAdd) {
		return inputDateTime.plusDays(daysToAdd);
	}

	public static LocalDateTime addHours(LocalDateTime inputDateTime, int hoursToAdd) {
		return inputDateTime.plusHours(hoursToAdd);
	}

	public static LocalDateTime addMinutes(LocalDateTime inputDateTime, int minutesToAdd) {
		return inputDateTime.plusMinutes(minutesToAdd);
	}
}
```
###### src\main\paddletask\common\util\LoggingHandler.java
``` java
package main.paddletask.common.util;

import java.util.logging.Logger;

public class LoggingHandler {
	
	/*** Variables ***/
	private static final String EMPTY = "";
	
	private static final Logger LOGGER = Logger.getLogger(EMPTY);

	/*** Methods ***/
	public void setupLoggingHandler() {
		//suppress useless logs to console
		supressConsoleOutput();
	}

	private void supressConsoleOutput() {
		LOGGER.removeHandler(LOGGER.getHandlers()[0]);
	}
}
```
###### src\main\paddletask\parser\api\CommandParser.java
``` java
package main.paddletask.parser.api;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import main.paddletask.command.api.Command;
import main.paddletask.common.exception.InvalidCommandFormatException;
import main.paddletask.parser.logic.ParseLogic;

public final class CommandParser {

	/*** Variables ***/
	private ParseLogic _parserLogic = new ParseLogic();
	private static final Logger LOGGER = LoggerFactory.getLogger(CommandParser.class);

	/*** Constructor ***/
	public CommandParser() {
		LOGGER.info("Initiating CommandParser");
	}

	/*** Methods ***/
	public Command parse(String userCommand) throws InvalidCommandFormatException {
		assert(userCommand != null);
		checkUserCommand(userCommand);
		try {
			return createCommand(userCommand);
		} catch (InvalidCommandFormatException e) {
			throw e;
		} catch (Throwable e) {
			String message = String.format("Failed to parse user input: %1$s", userCommand);
			LOGGER.error(message, e);
			throw new InvalidCommandFormatException("User input supplied was in an invalid format");
		}
	}
	
	//Overloaded parse for commands that require running index
	public Command parse(String userCommand, int[] stateArray) throws InvalidCommandFormatException {
		assert(userCommand != null && stateArray != null);
		checkUserCommand(userCommand);
		try {
			userCommand = _parserLogic.replaceRunningIndex(userCommand,stateArray);
			return parse(userCommand);
		} catch (InvalidCommandFormatException e) {
			throw e;
		} catch (Throwable e) {
			String message = String.format("Failed to parse user input: %1$s with running index", userCommand);
			LOGGER.error(message, e);
			throw new InvalidCommandFormatException("User input supplied was in an invalid format");
		}
	}
	
	private void checkUserCommand(String userCommand) throws InvalidCommandFormatException {
		userCommand = userCommand.trim();
		if (userCommand.length() <= 0) {
			LOGGER.error("User input string is of 0 length");
			throw new InvalidCommandFormatException("User input is blank");
		}
	}

	/**
	 * This method is invoked by logic to check if a command is stateful
	 * 
	 * @return <code>true</code> if command is stateful
	 * 		   <code>false</code> otherwise
	 */
	public boolean isStatefulCommand(String userCommand) throws InvalidCommandFormatException {
		checkUserCommand(userCommand);
		return _parserLogic.isStatefulCommand(userCommand);
	}

	/**
	 * This method is invoked by logic to check if a command requires
	 * a save state
	 * 
	 * @return <code>true</code> if command requires save state
	 * 		   <code>false</code> otherwise
	 */
	public boolean isSaveStateCommand(String userCommand) throws InvalidCommandFormatException {
		checkUserCommand(userCommand);
		return _parserLogic.isSaveStateCommand(userCommand);
	}

	private Command createCommand(String userCommand) throws Exception {
		assert(userCommand != null && _parserLogic != null);
		Command newCommand = _parserLogic.createCommand(userCommand);
		if (newCommand == null) {
			throw new InvalidCommandFormatException("Unable to create command with specified user input");
		}
		return newCommand;
	}
}
```
###### src\main\paddletask\parser\logic\ParseLogic.java
``` java
package main.paddletask.parser.logic;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;

import main.paddletask.command.api.*;
import main.paddletask.command.data.Option;
import main.paddletask.common.exception.InvalidCommandFormatException;
import main.paddletask.common.util.DateTimeHelper;

public class ParseLogic extends ParserBackend {
	
	/*** Constructor ***/
	public ParseLogic() {
		LOGGER.info("Initiating ParseLogic");
	}

	/*** Methods ***/
	public COMMAND_TYPE determineCommandType(String userCommand) {
		LOGGER.info("Attempt to determine command type from user input: {}", userCommand);
		assert(userCommand != null);
		String mainCommand = getMainCommand(userCommand).toLowerCase();
		if (mainCommand.equalsIgnoreCase(COMMANDS.ADD.toString()) 
			|| mainCommand.equalsIgnoreCase(COMMANDS.ADD_SHORT.toString())) {
			return COMMAND_TYPE.ADD;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.VIEW.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.VIEW_SHORT.toString())) {
			return COMMAND_TYPE.VIEW;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.EDIT.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.EDIT_SHORT.toString())) {
			return COMMAND_TYPE.EDIT;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.DELETE.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.DELETE_SHORT.toString())) {
			return COMMAND_TYPE.DELETE;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.COMPLETE.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.COMPLETE_SHORT.toString())) {
            return COMMAND_TYPE.COMPLETE;
        }
		else if (mainCommand.equalsIgnoreCase(COMMANDS.SEARCH.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.SEARCH_SHORT.toString())) {
			return COMMAND_TYPE.SEARCH;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.UNDO.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.UNDO_SHORT.toString())) {
			return COMMAND_TYPE.UNDO;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.REDO.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.REDO_SHORT.toString())) {
			return COMMAND_TYPE.REDO;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.CLEAR.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.CLEAR_SHORT.toString())) {
			return COMMAND_TYPE.CLEAR;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.HELP.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.HELP_SHORT.toString())) {
			return COMMAND_TYPE.HELP;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.SETDIRECTORY.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.SETDIRECTORY_SHORT.toString())) {
			return COMMAND_TYPE.SETDIRECTORY;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.TAG.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.TAG_SHORT.toString())) {
			return COMMAND_TYPE.TAG;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.UNTAG.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.UNTAG_SHORT.toString())) {
			return COMMAND_TYPE.UNTAG;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.MORE.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.MORE_SHORT.toString())) {
			return COMMAND_TYPE.MORE;
		}
		else if (mainCommand.equalsIgnoreCase(COMMANDS.EXIT.toString())
				|| mainCommand.equalsIgnoreCase(COMMANDS.EXIT_SHORT.toString())) {
			return COMMAND_TYPE.EXIT;
		}
		else {
			return COMMAND_TYPE.INVALID;
		}
	}
		
	public Command createCommand(String userCommand) throws Exception {
		LOGGER.info("Create command based on determined command type: {}", userCommand);
		assert(userCommand != null);
		COMMAND_TYPE commandType = determineCommandType(userCommand);
		Command newCommand = createCommandByType(commandType);
		processOptions(commandType, newCommand, userCommand);
		addCommandToList(newCommand, commandType);
		return newCommand;
	}
	
	private Command createCommandByType(COMMAND_TYPE commandType){
		switch (commandType) {
			case ADD:
				return new AddTaskCommand();
			case VIEW:
				return new ViewTaskCommand();
			case EDIT:
				return new EditTaskCommand();
			case DELETE:
				return new DeleteTaskCommand();
			case COMPLETE:
				return new CompleteTaskCommand();
			case SEARCH:
				return new SearchTaskCommand();
			case UNDO:
				return new UndoCommand();
			case REDO:
				return new RedoCommand();
			case CLEAR:
				return new ClearCommand();
			case HELP:
				return new HelpCommand();
			case SETDIRECTORY:
				return new SetDirectoryCommand();
			case MORE:
				return new MoreCommand();
			case TAG:
				return new TagTaskCommand();
			case UNTAG:
				return new UntagTaskCommand();
			case EXIT:
				return new ExitCommand();
			case INVALID:
				return null;
			default:
				LOGGER.error("commandType is corrupted and not within expectations");
				throw new Error("Corrupted commandType");
		}
	}

	private void addCommandToList(Command newCommand, ParseLogic.COMMAND_TYPE commandType) {
		assert(newCommand != null);
		if (!isInvalidTypeToAdd(commandType)) {
			Command.getCommandList().push(newCommand);
			Command.getUndoCommandList().clear();
		}
	}

	private void processOptions(COMMAND_TYPE commandType, Command newCommand, String userCommand) throws Exception {
		assert(newCommand != null && userCommand != null);
		List<String> commandList = breakDownCommand(userCommand);
		if (commandType == COMMAND_TYPE.SEARCH) {
			addPossibleDates(newCommand, commandList);
		} else if (commandType == COMMAND_TYPE.TAG || commandType == COMMAND_TYPE.UNTAG) {
			addTags(newCommand, commandList);
		}
		addOptionsToCommand(commandType, newCommand, commandList);
	}

	private void addOptionsToCommand(COMMAND_TYPE commandType, Command command, List<String> commandList) throws Exception {
		LOGGER.info("Attempt to add list of options to Command specified");
		assert(command != null && commandList != null);
		EnumMap<OPTIONS, TYPE> optionMap = getOptionMap(commandType);
		for (int i = commandList.size() - 1; i > -1; i--) {
			if (isOption(optionMap, commandList.get(i))) {
				String option = commandList.get(i);
				List<String> subList = commandList.subList(i, commandList.size());
				Option commandOption = getOption(subList, optionMap);
				if (!isOptionValid(optionMap, option, commandOption)) {
					continue;
				}
				if (!addOption(option, commandOption, command)) {
					LOGGER.error("Unable to add option into command due to unknown reasons.");
					throw new Error("Unknown error has occured.");
				}
				subList.clear();
			}
		}
	}
	
	private boolean addOption(String option, Option commandOption, Command command) {
		option = getFullOptionName(option);
		return command.addOption(option, commandOption);
	}
	
	private boolean isOptionValid (EnumMap<OPTIONS, TYPE> optionMap, String option, Option commandOption) {
		return !(!isOptionalOrNoArgumentType(optionMap, option) && commandOption == null);
	}
	
	private Option getOption(List<String> commandList, EnumMap<OPTIONS, TYPE> optionMap) throws Exception {
		assert(optionMap != null && commandList != null);
		Option newOption = null;
		String option = commandList.remove(0);
		LOGGER.info("Retrieve expected value of specified option: {}", option);
		for (OPTIONS opt : optionMap.keySet()) {
			if (option.equalsIgnoreCase(opt.toString())) {
				switch (optionMap.get(opt)) {
				case STRING:
					newOption = expectString(commandList, false);
					break;
				case STRING_ARRAY:
					newOption = expectStringArray(commandList, false);
					break;
				case INTEGER:
					newOption = expectInteger(commandList, false);
					break;
				case INTEGER_ARRAY:
					newOption = expectIntegerArray(commandList, false);
					break;
				case DATE:
					newOption = expectDate(commandList, false);
					break;
				case DAY:
					newOption = expectDay(commandList, false);
					break;
				case STRING_OPT:
					newOption = expectString(commandList, true);
					break;
				case STRING_ARRAY_OPT:
					newOption = expectStringArray(commandList, true);
					break;
				case INTEGER_OPT:
					newOption = expectInteger(commandList, true);
					break;
				case INTEGER_ARRAY_OPT: 
					newOption = expectIntegerArray(commandList, true);
					break;
				case DATE_OPT:
					newOption = expectDate(commandList, true);
					break;
				case NONE:
					commandList.clear();
					return null;
				}
				return newOption;
			}
		}
		// failed to get anything
		LOGGER.error("option keyword is not within expectations");
		throw new Error("corrupted variable: option");
	}
	
	public void addPossibleDates(Command command, List<String> commandList) throws Exception {
		Option dateOption = scanForDates(commandList, true);
		command.addOption("searchDates", dateOption);
	}
	
	private boolean isCommandListValid(List<String> commandList, boolean optional) throws Exception {
		if (commandList.isEmpty()) {
			if (optional) {
				return false;
			} else {
				LOGGER.error("Expected input not found");
				throw new InvalidCommandFormatException("Expected input not found!");
			}
		}
		return true;
	}
	
	private Option scanForDates(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse expected string from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		String expectedDate = formatDates(commandList);
		List<LocalDateTime> dates = parseDates(expectedDate);
		while (!dates.isEmpty()) {
			commandOption.addValue(dates.remove(0));
		}
		return commandOption;
	}
	
	/** 
	 * This method is used invoked to convert dd/mm/yyyy dates
	 * to yyyy/mm/dd so there is no ambiguity and natty is able
	 * to parse the dates correctly. (Natty reads dd/mm/yyyy 
	 * dates as mm/dd/yyyy dates.)
	 * 
	 * @param commandList
	 * @return
	 */
	private String formatDates(List<String> commandList) {
		StringBuilder stringOption = new StringBuilder();
		for (String s : commandList) { 
			LOGGER.debug("Expecting a list of Strings");
			if (DateTimeHelper.isDate(s)) {
				String[] testedString = s.split("/");
				s = String.format(DATE_FORMAT, testedString[2], testedString[1], testedString[0]);
			}
			stringOption.append(s);
			stringOption.append(SPACE);
		}
		return stringOption.toString().trim();
	}

	private Option expectDay(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse expected array of integers from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		for (String s : commandList) {
			if (!isDay(s)) {
				return null;
			}
			commandOption.addValue(s);
		}
		return commandOption;
	}

	private Option expectIntegerArray(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse expected array of integers from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		for (String s : commandList) {
			Integer parsedInt = tryParseInteger(s);
			if (!isParsedIntValid(parsedInt)) {
				return null;
			}
			commandOption.addValue(parsedInt);
		}
		return commandOption;
	}
	
	private boolean isParsedIntValid(Integer parsedInt) {
		return !(parsedInt == null || parsedInt < 0);
	}
	
	private Option expectString(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse expected string from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		String expectedString = findString(commandList);  
		commandOption.addValue(expectedString);
		return commandOption;
	}
	
	private String findString(List<String> commandList) {
		StringBuilder stringOption = new StringBuilder();
		for (String s : commandList) { 
			LOGGER.debug("Expecting a list of Strings");
			stringOption.append(s);
			stringOption.append(SPACE);
		}
		return stringOption.toString().trim();
	}
	
	private Option expectInteger(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse single expected integer from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		LOGGER.warn("expectedInt = commandList.get(0) may cause index out of bounds exception");
		String expectedInt = commandList.get(0);
		Integer parsedInt = tryParseInteger(expectedInt);
		if (!isParsedIntValid(parsedInt)) {
			return null;
		}
		commandOption.addValue(parsedInt);
		return commandOption;
	}
	
	private Option expectStringArray(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse expected array of Strings from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		for (String s : commandList) {
			commandOption.addValue(s);
		}
		return commandOption;
	}
	
	public void addTags(Command command, List<String> commandList) throws Exception {
		Option hashtags = expectHashtagArray(commandList, true);
		command.addOption(OPTIONS.HASHTAG.toString(), hashtags);
	}
	
	private Option expectHashtagArray(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse expected array of Strings from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		for (String s : commandList) {
			if (isValidTag(s)) {
				commandOption.addValue(s);
			}
		}
		checkValidOption(commandOption);
		return commandOption;
	}
	
	private void checkValidOption(Option commandOption) throws InvalidCommandFormatException {
		if (commandOption.getValuesCount() == 0) {
			LOGGER.error("Expected input not found");
			throw new InvalidCommandFormatException("Expected input not found!");
		}
	}
	
	private boolean isValidTag(String tag) {
		return tag.startsWith(OPTIONS.HASHTAG.toString());
	}
	
	private Option expectDate(List<String> commandList, boolean optional) throws Exception {
		LOGGER.info("Attempt to parse expected string from user input");
		assert(commandList != null);
		Option commandOption = new Option();
		if (!isCommandListValid(commandList, optional)) {
			return null;
		}
		String expectedDate = formatDates(commandList);
		LocalDateTime date = parseDate(expectedDate);
		if (date == null) {
			return null;
		}
		commandOption.addValue(date);
		return commandOption;
	}
	
	private boolean isInvalidTypeToAdd(COMMAND_TYPE commandType) {
		switch (commandType) {
			case UNDO:
			case REDO:
			case VIEW:
			case CLEAR:
			case HELP:
			case SEARCH:
				return true;
			default:
				return false;
		}
	}
	
	public boolean isStatefulCommand(String userCommand) {
		return isStatefulCommand(determineCommandType(userCommand));
	}
	
	public boolean isSaveStateCommand(String userCommand) {
		return isSaveStateCommand(determineCommandType(userCommand));
	}
	
	private boolean isStatefulCommand(COMMAND_TYPE commandType) {
		switch (commandType) {
			case EDIT:
			case DELETE:
			case COMPLETE:
			case MORE:
			case TAG:
			case UNTAG:
				return true;
			default:
				return false;
		}
	}
	
	private boolean isSaveStateCommand(COMMAND_TYPE commandType) {
		switch (commandType) {
			case VIEW:
			case SEARCH:
				return true;
			default:
				return false;
		}
	}
	
	public String replaceRunningIndex(String userCommand, int[] stateArray) throws Exception {
		Integer taskID = -1;
		List<String> commandTokens = getStatefulCommandTokens(userCommand);
		for (String s : commandTokens) {
			if ((taskID = tryParseInteger(s)) != null) {
				checkTaskID(taskID, userCommand);
				String oldID = String.format(OLD_TASKID_FORMAT, taskID);
				String newID = String.format(NEW_TASKID_FORMAT, stateArray[taskID - 1]);
				userCommand = userCommand.replaceFirst(oldID, newID);
			}
		}
		return userCommand.trim();
	}
	
	private List<String> getStatefulCommandTokens(String userCommand) {
		COMMAND_TYPE commandType = determineCommandType(userCommand);
		List<String> commandTokens = null;
		if (commandType == COMMAND_TYPE.EDIT) {
			commandTokens = new ArrayList<String>();
			// if edit, get ID of edit
			commandTokens.add(userCommand.split(SPACE)[1]);
		} else {
			commandTokens = breakDownCommand(userCommand);
		}
		return commandTokens;
	}

	private void checkTaskID(int taskID, String userCommand) throws InvalidCommandFormatException {
		if (taskID <= 0) {
			LOGGER.error("Failed to parse user input: {}. Invalid ID provided", userCommand);
			throw new InvalidCommandFormatException("Task with the following Task ID does not exist!");
		}
	}
	
	private Integer tryParseInteger(String s1) {
		for (int i = 0; i < s1.length(); i++) {
			if(!Character.isDigit(s1.charAt(i))) {
				return null;
			}
		}
		return Integer.parseInt(s1);
	}
}
```
###### src\main\paddletask\parser\logic\ParserBackend.java
``` java
package main.paddletask.parser.logic;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.joestelmach.natty.DateGroup;

import main.paddletask.common.data.ParserConstants;
import main.paddletask.common.util.DateTimeHelper;

class ParserBackend implements ParserConstants {

	/*** Variables ***/
	protected static final String EMPTY_STRING = "";
	protected static final String SPACE = " ";
	protected static final char SPACES = ' ';
	protected static final char QUOTES = '"';
	protected static final String DATE_FORMAT = "%1$s/%2$s/%3$s";
	protected static final String OLD_TASKID_FORMAT = "\\s+%1$d(\\s+|$)";
	protected static final String NEW_TASKID_FORMAT = " %1$d ";
	
	protected static final boolean OPTIONAL = true;
	protected static final boolean NOT_OPTIONAL = false;
	
	private static final EnumMap<OPTIONS, TYPE> addOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> viewOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> editOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> deleteOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> completeOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> searchOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> helpOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> setDirectoryOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> moreOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> tagOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> untagOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> clearOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> exitOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> redoOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	private static final EnumMap<OPTIONS, TYPE> undoOptions = new EnumMap<OPTIONS, TYPE>(OPTIONS.class);
	
	protected static final Logger LOGGER = LoggerFactory.getLogger(ParseLogic.class);
	private static HashMap<String, String> _shortHandMap = new HashMap<String, String>();
	private static HashMap<COMMAND_TYPE, EnumMap<OPTIONS, TYPE>> _optionsMap = new HashMap<COMMAND_TYPE, EnumMap<OPTIONS, TYPE>>();
	private static com.joestelmach.natty.Parser _dateParser = new com.joestelmach.natty.Parser();
	
	/*** Constructor ***/
	public ParserBackend() {
		setupCommandEnums();
	}

	/*** Methods ***/
	private void setupCommandEnums() {
		setupAddOption();
		setupViewOption();
		setupEditOption();
		setupDeleteOption();
		setupCompleteOption();
		setupSearchOption();
		setupHelpOption();
		setupSetDirectoryOption();
		setupTagOption();
		setupUntagOption();
		setupMoreOption();
		setupTrivialOptions();
		setUp_shortHandMapping();
	}

	private void setUp_shortHandMapping() {
		_shortHandMap.put(OPTIONS.ADD_SHORT.toString(), OPTIONS.ADD.toString());
		_shortHandMap.put(OPTIONS.VIEW_SHORT.toString(), OPTIONS.VIEW.toString());
		_shortHandMap.put(OPTIONS.EDIT_SHORT.toString(), OPTIONS.EDIT.toString());
		_shortHandMap.put(OPTIONS.DELETE_SHORT.toString(), OPTIONS.DELETE.toString());
		_shortHandMap.put(OPTIONS.COMPLETE_SHORT.toString(), OPTIONS.COMPLETE.toString());
		_shortHandMap.put(OPTIONS.SEARCH_SHORT.toString(), OPTIONS.SEARCH.toString());
		_shortHandMap.put(OPTIONS.BY_SHORT.toString(), OPTIONS.BY.toString());
		_shortHandMap.put(OPTIONS.UNDO_SHORT.toString(), OPTIONS.UNDO.toString());
		_shortHandMap.put(OPTIONS.REDO_SHORT.toString(), OPTIONS.REDO.toString());
		_shortHandMap.put(OPTIONS.REMIND_SHORT.toString(), OPTIONS.REMIND.toString());
		_shortHandMap.put(OPTIONS.CLEAR_SHORT.toString(), OPTIONS.CLEAR.toString());
		_shortHandMap.put(OPTIONS.EXIT_SHORT.toString(), OPTIONS.EXIT.toString());
		_shortHandMap.put(OPTIONS.BETWEEN_SHORT.toString(), OPTIONS.BETWEEN.toString());
		_shortHandMap.put(OPTIONS.AND_SHORT.toString(), OPTIONS.AND.toString());
		_shortHandMap.put(OPTIONS.DESC_SHORT.toString(), OPTIONS.DESC.toString());
		_shortHandMap.put(OPTIONS.STARTDATE_SHORT.toString(), OPTIONS.STARTDATE.toString());
		_shortHandMap.put(OPTIONS.STARTTIME_SHORT.toString(), OPTIONS.STARTTIME.toString());
		_shortHandMap.put(OPTIONS.ENDDATE_SHORT.toString(), OPTIONS.ENDDATE.toString());
		_shortHandMap.put(OPTIONS.ENDTIME_SHORT.toString(), OPTIONS.ENDTIME.toString());
		_shortHandMap.put(OPTIONS.ALL_SHORT.toString(), OPTIONS.ALL.toString());
		_shortHandMap.put(OPTIONS.VIEW_COMPLETE_SHORT.toString(), OPTIONS.COMPLETE.toString());
		_shortHandMap.put(OPTIONS.TODAY_SHORT.toString(), OPTIONS.TODAY.toString());
		_shortHandMap.put(OPTIONS.TOMORROW_SHORT.toString(), OPTIONS.TOMORROW.toString());
		_shortHandMap.put(OPTIONS.WEEK_SHORT.toString(), OPTIONS.WEEK.toString());
		_shortHandMap.put(OPTIONS.MONTH_SHORT.toString(), OPTIONS.MONTH.toString());
		_shortHandMap.put(OPTIONS.HELP_SHORT.toString(), OPTIONS.HELP.toString());
		_shortHandMap.put(OPTIONS.SETDIRECTORY_SHORT.toString(), OPTIONS.SETDIRECTORY.toString());
		_shortHandMap.put(OPTIONS.MORE_SHORT.toString(), OPTIONS.MORE.toString());
		_shortHandMap.put(OPTIONS.TAG_SHORT.toString(), OPTIONS.TAG.toString());
		_shortHandMap.put(OPTIONS.UNTAG_SHORT.toString(), OPTIONS.UNTAG.toString());
		_shortHandMap.put(OPTIONS.PRIORITY_SHORT.toString(), OPTIONS.PRIORITY.toString());
		_shortHandMap.put(OPTIONS.REPEAT_SHORT.toString(), OPTIONS.REPEAT.toString());
	}
	
	private void setupTrivialOptions() {
		clearOptions.put(OPTIONS.CLEAR, TYPE.NONE);
		clearOptions.put(OPTIONS.CLEAR_SHORT, TYPE.NONE);
		_optionsMap.put(COMMAND_TYPE.CLEAR, clearOptions);
		exitOptions.put(OPTIONS.EXIT, TYPE.NONE);
		exitOptions.put(OPTIONS.EXIT_SHORT, TYPE.NONE);
		_optionsMap.put(COMMAND_TYPE.EXIT, exitOptions);
		redoOptions.put(OPTIONS.REDO, TYPE.NONE);
		redoOptions.put(OPTIONS.REDO_SHORT, TYPE.NONE);
		_optionsMap.put(COMMAND_TYPE.REDO, redoOptions);
		undoOptions.put(OPTIONS.UNDO, TYPE.NONE);
		undoOptions.put(OPTIONS.UNDO_SHORT, TYPE.NONE);
		_optionsMap.put(COMMAND_TYPE.UNDO, undoOptions);
	}

	private void setupMoreOption() {
		moreOptions.put(OPTIONS.MORE, TYPE.INTEGER);
		moreOptions.put(OPTIONS.MORE_SHORT, TYPE.INTEGER);
		_optionsMap.put(COMMAND_TYPE.MORE, moreOptions);
	}

	private void setupUntagOption() {
		untagOptions.put(OPTIONS.UNTAG, TYPE.INTEGER);
		untagOptions.put(OPTIONS.UNTAG_SHORT, TYPE.INTEGER);
		_optionsMap.put(COMMAND_TYPE.UNTAG, untagOptions);
	}

	private void setupTagOption() {
		tagOptions.put(OPTIONS.TAG, TYPE.INTEGER);
		tagOptions.put(OPTIONS.TAG_SHORT, TYPE.INTEGER);
		_optionsMap.put(COMMAND_TYPE.TAG, tagOptions);
	}

	private void setupSetDirectoryOption() {
		setDirectoryOptions.put(OPTIONS.SETDIRECTORY, TYPE.STRING);
		setDirectoryOptions.put(OPTIONS.SETDIRECTORY_SHORT, TYPE.STRING);
		_optionsMap.put(COMMAND_TYPE.SETDIRECTORY, setDirectoryOptions);
	}

	private void setupHelpOption() {
		helpOptions.put(OPTIONS.HELP, TYPE.STRING_OPT);
		helpOptions.put(OPTIONS.HELP_SHORT, TYPE.STRING_OPT);
		_optionsMap.put(COMMAND_TYPE.HELP, helpOptions);
	}

	private void setupSearchOption() {
		searchOptions.put(OPTIONS.SEARCH, TYPE.STRING_ARRAY);
		searchOptions.put(OPTIONS.SEARCH_SHORT, TYPE.STRING_ARRAY);
		_optionsMap.put(COMMAND_TYPE.SEARCH, searchOptions);
	}

	private void setupCompleteOption() {
		completeOptions.put(OPTIONS.COMPLETE, TYPE.INTEGER_ARRAY);
		completeOptions.put(OPTIONS.COMPLETE_SHORT, TYPE.INTEGER_ARRAY);
		_optionsMap.put(COMMAND_TYPE.COMPLETE, completeOptions);
	}

	private void setupDeleteOption() {
		deleteOptions.put(OPTIONS.DELETE, TYPE.INTEGER_ARRAY);
		deleteOptions.put(OPTIONS.DELETE_SHORT, TYPE.INTEGER_ARRAY);
		deleteOptions.put(OPTIONS.BETWEEN, TYPE.DATE);
		deleteOptions.put(OPTIONS.AND, TYPE.DATE);
		deleteOptions.put(OPTIONS.BETWEEN_SHORT, TYPE.DATE);
		deleteOptions.put(OPTIONS.AND_SHORT, TYPE.DATE);
		_optionsMap.put(COMMAND_TYPE.DELETE, deleteOptions);
	}

	private void setupEditOption() {
		editOptions.put(OPTIONS.EDIT, TYPE.INTEGER);
		editOptions.put(OPTIONS.DESC, TYPE.STRING);
		editOptions.put(OPTIONS.REMIND, TYPE.DATE);
		
		editOptions.put(OPTIONS.STARTDATE, TYPE.DATE);
		editOptions.put(OPTIONS.STARTTIME, TYPE.DATE);
		editOptions.put(OPTIONS.ENDDATE, TYPE.DATE);
		editOptions.put(OPTIONS.ENDTIME, TYPE.DATE);

		editOptions.put(OPTIONS.PRIORITY, TYPE.INTEGER);
		editOptions.put(OPTIONS.REPEAT, TYPE.DAY);
		
		editOptions.put(OPTIONS.EDIT_SHORT, TYPE.INTEGER);
		editOptions.put(OPTIONS.DESC_SHORT, TYPE.STRING);
		editOptions.put(OPTIONS.REMIND_SHORT, TYPE.DATE);
		
		editOptions.put(OPTIONS.STARTDATE_SHORT, TYPE.DATE);
		editOptions.put(OPTIONS.STARTTIME_SHORT, TYPE.DATE);
		editOptions.put(OPTIONS.ENDDATE_SHORT, TYPE.DATE);
		editOptions.put(OPTIONS.ENDTIME_SHORT, TYPE.DATE);

		editOptions.put(OPTIONS.PRIORITY_SHORT, TYPE.INTEGER);
		editOptions.put(OPTIONS.REPEAT, TYPE.DAY);
		_optionsMap.put(COMMAND_TYPE.EDIT, editOptions);
	}

	private void setupViewOption() {
		viewOptions.put(OPTIONS.VIEW, TYPE.INTEGER_ARRAY_OPT);
		viewOptions.put(OPTIONS.COMPLETE, TYPE.NONE);
		viewOptions.put(OPTIONS.ALL, TYPE.NONE);
		viewOptions.put(OPTIONS.TODAY, TYPE.NONE);
		viewOptions.put(OPTIONS.TOMORROW, TYPE.NONE);
		viewOptions.put(OPTIONS.WEEK, TYPE.NONE);
		viewOptions.put(OPTIONS.MONTH, TYPE.NONE);
		
		viewOptions.put(OPTIONS.VIEW_SHORT, TYPE.INTEGER_ARRAY_OPT);
		viewOptions.put(OPTIONS.VIEW_COMPLETE_SHORT, TYPE.NONE);
		viewOptions.put(OPTIONS.ALL_SHORT, TYPE.NONE);
		viewOptions.put(OPTIONS.TODAY_SHORT, TYPE.NONE);
		viewOptions.put(OPTIONS.TOMORROW_SHORT, TYPE.NONE);
		viewOptions.put(OPTIONS.WEEK_SHORT, TYPE.NONE);
		viewOptions.put(OPTIONS.MONTH_SHORT, TYPE.NONE);
		_optionsMap.put(COMMAND_TYPE.VIEW, viewOptions);
	}

	private void setupAddOption() {
		addOptions.put(OPTIONS.ADD, TYPE.STRING);
		addOptions.put(OPTIONS.BY, TYPE.DATE);
		addOptions.put(OPTIONS.REMIND, TYPE.DATE);
		addOptions.put(OPTIONS.BETWEEN, TYPE.DATE);
		addOptions.put(OPTIONS.AND, TYPE.DATE);
		addOptions.put(OPTIONS.PRIORITY, TYPE.INTEGER);
		addOptions.put(OPTIONS.REPEAT, TYPE.DAY);

		addOptions.put(OPTIONS.ADD_SHORT, TYPE.STRING);
		addOptions.put(OPTIONS.BY_SHORT, TYPE.DATE);
		addOptions.put(OPTIONS.REMIND_SHORT, TYPE.DATE);
		addOptions.put(OPTIONS.BETWEEN_SHORT, TYPE.DATE);
		addOptions.put(OPTIONS.AND_SHORT, TYPE.DATE);
		addOptions.put(OPTIONS.PRIORITY_SHORT, TYPE.INTEGER);
		addOptions.put(OPTIONS.REPEAT, TYPE.DAY);
		_optionsMap.put(COMMAND_TYPE.ADD, addOptions);
	}
	
	protected LocalDateTime parseDate(String expectedDate) {
		List<DateGroup> groups = _dateParser.parse(expectedDate);
		for(DateGroup group : groups) {
			List<Date> dates = group.getDates();
			if (!dates.isEmpty()) {
				return DateTimeHelper.setTimezoneForDate(dates.get(0));
			}
		}
		return null;
	}
	
	protected List<LocalDateTime> parseDates(String commandString) {
		List<DateGroup> groups = _dateParser.parse(commandString);
		List<LocalDateTime> parsedDates = new ArrayList<LocalDateTime>();
		for(DateGroup group : groups) {
			List<Date> dates = group.getDates();
			while (!dates.isEmpty()) {
				parsedDates.add(DateTimeHelper.setTimezoneForDate(dates.remove(0)));
			}
		}
		return parsedDates;
	}
	
	protected List<String> breakDownCommand(String userCommand) {
		LOGGER.info("Attempt to breakdown user input into chunks of words.");
		assert(userCommand != null && userCommand.length() > 0);
		return preprocessUserCommand(userCommand);
	}
	
	protected String getMainCommand(String userCommand) {
		LOGGER.info("Get first word of user input: {}", userCommand);
		assert(userCommand != null && userCommand.length() > 0);
		return userCommand.split(SPACE)[0];
	}
	
	protected boolean isOption(EnumMap<OPTIONS, TYPE> optionMap, String option) {
		for (OPTIONS value : optionMap.keySet()) {
			if (value.toString().equalsIgnoreCase(option)) {
				return true;
			}
		}
		return false;
	}
	
	protected boolean isOptionalOrNoArgumentType(EnumMap<OPTIONS, TYPE> optionMap, String option) {
		for (OPTIONS value : optionMap.keySet()) {
			if (value.toString().equalsIgnoreCase(option)) {
				return isTrivialOption(optionMap.get(value));
			}
		}
		return false;
	}
	
	protected boolean isDay(String day) {
		for (DAY d : DAY.values()) {
			if (d.toString().equalsIgnoreCase(day)) {
				return true;
			}
		}
		return false;
	}
	
	protected String getFullOptionName(String option) {
		if (_shortHandMap.containsKey(option)) {
			return _shortHandMap.get(option);
		} else {
			return option;
		}
	}
	
	private boolean isTrivialOption(TYPE optionType) {
		switch (optionType) {
			case NONE:
			case STRING_OPT:
			case INTEGER_OPT:
			case STRING_ARRAY_OPT:
			case INTEGER_ARRAY_OPT:
			case DATE_OPT:
				return true;
			default:
				return false;
		}
	}
	
	protected EnumMap<OPTIONS, TYPE> getOptionMap(COMMAND_TYPE commandType) {
		if (!_optionsMap.containsKey(commandType)) {
			LOGGER.error("commandType is corrupted and not within expectations");
			throw new Error("Corrupted commandType");
		}
		return _optionsMap.get(commandType);
	}
	
	private List<String> preprocessUserCommand(String userCommand) {
		List<String> processedCommand = new ArrayList<String>();
		int head = 0;
		for (int i = 0; !isEOL(userCommand, i); i++) {
			if (isEOL(userCommand, i + 1)) {
				addTo(processedCommand, userCommand, head, i + 1);
			} else if (isSpace(userCommand, i)) {
				addTo(processedCommand, userCommand, head, i);
				head = i + 1;
			} else if (isQuote(userCommand, i)) {
				int j = i + 1;
				while (!isEOL(userCommand, j) && !isQuote(userCommand, j)) {
					j++;
				}
				if (!isEOL(userCommand, j)) {
					i = j + 1;
					addTo(processedCommand, userCommand, head + 1, j);
					head = i + 1;
				}
			}
		}
		return processedCommand;
	}
	
	private boolean isQuote(String s, int i) {
		return s.charAt(i) == QUOTES;
	}
	
	private boolean isSpace(String s, int i) {
		return s.charAt(i) == SPACES;
	}
	
	private boolean isEOL(String s, int i) {
		return i >= s.length();
	}
	
	private String substring(String s, int i, int j) {
		return s.substring(i, j);
	}
	
	private void addTo(List<String> command, String s, int i, int j) {
		command.add(substring(s, i, j));
	}
}
```
###### src\main\paddletask\ui\view\MainFrame.java
``` java
	/**
	 * This method is invoked to hide and minimize the
	 * application to window's system tray
	 */
	private static void minimizeToTray() {
		int state = frame.getExtendedState(); // get current state
		state = state | Frame.ICONIFIED; // add minimized to the state
		frame.setExtendedState(state);
		frame.setVisible(false); // hide the window
		isMinimized = true;
	}


	/**
	 * This method is invoked to restore and unhide the
	 * application from window's system tray
	 */
	private static void restoreToDesktop() {
		int state = frame.getExtendedState(); // get current state
		state = state & ~Frame.ICONIFIED; // remove minimized to the state
		frame.setExtendedState(state);
		frame.setVisible(true); // unhide the window
		frame.toFront();
		frame.repaint();
		panel.setInputFocus();
		isMinimized = false;
	}

	/**
	 * This method is invoked to check if the system tray
	 * is accessible by the application
	 * 
	 * @return <code>true</code> if system tray is accessible
	 *         <code>false</code> otherwise
	 */
	private static boolean isSystemTrayReady() {
		if (!SystemTray.isSupported()) {
			return false;
		}
		SystemTray tray = SystemTray.getSystemTray();
		URL resource = MainFrame.class.getResource("/main/resources/images/calendar.png");
		Image image = Toolkit.getDefaultToolkit().getImage(resource);
		frame.setIconImage(image);
		TrayIcon trayIcon = new TrayIcon(image, "PaddleTask");
		trayIcon.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				restoreToDesktop();
			}
		});
		try {
			tray.add(trayIcon);
		} catch (AWTException e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	/**
	 * This method is invoked to implement a global keystroke hook
	 * onto the user's system
	 */
	private static void implementNativeKeyHook() throws Exception {
		GlobalScreen.registerNativeHook();

		//supress all warnings except level warning
		Logger logger = Logger.getLogger(GlobalScreen.class.getPackage().getName());
		logger.setLevel(Level.WARNING);

		GlobalScreen.addNativeKeyListener(new NativeKeyListener() {

			@Override
			public void nativeKeyTyped(NativeKeyEvent e) { }

			@Override
			public void nativeKeyReleased(NativeKeyEvent e) { }

			// only required to hook the key press event
			// and check for a combination of LCTRL + SPACE
			@Override
			public void nativeKeyPressed(NativeKeyEvent e) {
				if (e.getModifiers() == (NativeKeyEvent.CTRL_L_MASK)) {
					if (e.getKeyCode() == NativeKeyEvent.VC_SPACE) {
						if (isMinimized) {
							restoreToDesktop();
						} else {
							minimizeToTray();
						}
					}
				}
			}
		});
	}
}
```
###### src\test\cases\TestCommandParser.java
``` java
package test.cases;

import static org.junit.Assert.*;

import java.io.File;
import java.lang.reflect.Field;

import org.junit.Before;
import org.junit.Test;

import main.paddletask.common.data.ParserConstants.COMMAND_TYPE;
import main.paddletask.parser.api.CommandParser;
import main.paddletask.parser.logic.ParseLogic;
import main.paddletask.task.api.TaskController;

public class TestCommandParser {
	/*
	 * Test Assumption:
	 * 1. StorageController is working correctly
	 * 2. TaskController is working correctly
	 * 3. CommandParser is working correctly
	 */

	/*** Variables ***/
	protected static TaskController taskController;
	protected static CommandParser parser;

	/*** Setup ***/
	@Before
	public void setUp() throws Exception {
		taskController = TaskController.getInstance();
		parser = new CommandParser();
		
		// wipe out all data within task.xml
		File f = new File("task.xml");
		f.delete();
	}

	@Test
	public void testInvalidCommands() throws Exception{
		checkCommand(COMMAND_TYPE.INVALID, "");
		checkCommand(COMMAND_TYPE.INVALID, "hello");
		checkCommand(COMMAND_TYPE.INVALID, "HELLO");
	}

	@Test(expected=NullPointerException.class)
	public void testNullCommands() throws Exception{
		checkCommand(COMMAND_TYPE.INVALID, null);
	}
	
	/**
	 * Testing add commands
	 * @throws Exception 
	 */
	@Test
	public void testCommandAdd() throws Exception{
		checkCommand(COMMAND_TYPE.ADD, "add");
		checkCommand(COMMAND_TYPE.ADD, "ADD");
		checkCommand(COMMAND_TYPE.ADD, "aDd");
		checkCommand(COMMAND_TYPE.ADD, "aDD");
		
		checkCommand(COMMAND_TYPE.ADD, "/a");
		checkCommand(COMMAND_TYPE.ADD, "/A");
	}
	
	/**
	 * Test clear data
	 * @throws Exception 
	 */
	@Test
	public void testCommandClear() throws Exception{
		checkCommand(COMMAND_TYPE.CLEAR, "CLEAR");
		checkCommand(COMMAND_TYPE.CLEAR, "clear");
		checkCommand(COMMAND_TYPE.CLEAR, "/cl");
		checkCommand(COMMAND_TYPE.CLEAR, "/CL");
	}
	
	/**
	 * Test Delete
	 * @throws Exception 
	 */
	@Test
	public void testCommandDelete() throws Exception{
		checkCommand(COMMAND_TYPE.DELETE, "DELETE");
		checkCommand(COMMAND_TYPE.DELETE, "delete");
		checkCommand(COMMAND_TYPE.DELETE, "/d");
		checkCommand(COMMAND_TYPE.DELETE, "/D");
	}
	
	/**
	 * Test edit 
	 * @throws Exception 
	 */
	@Test
	public void testCommandEdit() throws Exception{
		checkCommand(COMMAND_TYPE.EDIT, "EDIT");
		checkCommand(COMMAND_TYPE.EDIT, "edit");
		checkCommand(COMMAND_TYPE.EDIT, "/e");
		checkCommand(COMMAND_TYPE.EDIT, "/E");
	}
	
	/**
	 * Test search
	 * @throws Exception 
	 */
	@Test
	public void testCommandSearch() throws Exception{
		checkCommand(COMMAND_TYPE.SEARCH, "SEARCH");
		checkCommand(COMMAND_TYPE.SEARCH, "search");
		checkCommand(COMMAND_TYPE.SEARCH, "/s");
	}
	
	/**
	 * Test list 
	 * @throws Exception 
	 */
	@Test
	public void testCommandList() throws Exception{
		checkCommand(COMMAND_TYPE.VIEW, "VIEW");
		checkCommand(COMMAND_TYPE.VIEW, "view");
		checkCommand(COMMAND_TYPE.VIEW, "/v");
		checkCommand(COMMAND_TYPE.VIEW, "/V");
	}
	
	/**
	 * Test redo
	 * @throws Exception 
	 */
	@Test
	public void testCommandRedo() throws Exception{
		checkCommand(COMMAND_TYPE.REDO, "REDO");
		checkCommand(COMMAND_TYPE.REDO, "redo");
		checkCommand(COMMAND_TYPE.REDO, "/r");
		checkCommand(COMMAND_TYPE.REDO, "/R");
	}
	
	/**
	 * Test done
	 * @throws Exception 
	 */
	@Test
	public void testCommandDone() throws Exception{
		checkCommand(COMMAND_TYPE.COMPLETE, "COMPLETE");
		checkCommand(COMMAND_TYPE.COMPLETE, "complete");
		checkCommand(COMMAND_TYPE.COMPLETE, "/c");
		checkCommand(COMMAND_TYPE.COMPLETE, "/C");
	}
	
	/**
	 * Test undo
	 * @throws Exception 
	 */
	@Test
	public void testCommandUndo() throws Exception{
		checkCommand(COMMAND_TYPE.UNDO, "UNDO");
		checkCommand(COMMAND_TYPE.UNDO, "undo");
		checkCommand(COMMAND_TYPE.UNDO, "/u");
		checkCommand(COMMAND_TYPE.UNDO, "/U");
	}
	
	/**
	 * Test exit
	 * @throws Exception 
	 */
	@Test
	public void testCommandExit() throws Exception{
		checkCommand(COMMAND_TYPE.EXIT, "EXIT");
		checkCommand(COMMAND_TYPE.EXIT, "exit");
		checkCommand(COMMAND_TYPE.EXIT, "/ex");
		checkCommand(COMMAND_TYPE.EXIT, "/EX");
	}
	
	/**
	 * Test help
	 * @throws Exception 
	 */
	@Test
	public void testCommandHelp() throws Exception{
		checkCommand(COMMAND_TYPE.HELP, "HELP");
		checkCommand(COMMAND_TYPE.HELP, "help");
		checkCommand(COMMAND_TYPE.HELP, "/h");
		checkCommand(COMMAND_TYPE.HELP, "/H");
	}
	
	/** 
	 * Testing Any order of Commands
	 * @throws Exception 
	 */
	@Test
	public void testCommand() throws Exception {
		
		checkCommand(COMMAND_TYPE.ADD, "add");
		checkCommand(COMMAND_TYPE.ADD, "/a");
		checkCommand(COMMAND_TYPE.ADD, "add ");
		
		checkCommand(COMMAND_TYPE.DELETE, "delete");
		checkCommand(COMMAND_TYPE.INVALID, "   delete\n");
		checkCommand(COMMAND_TYPE.INVALID, "   /d");
		
		checkCommand(COMMAND_TYPE.COMPLETE, "complete");
		
		checkCommand(COMMAND_TYPE.CLEAR, "/cl");
		
		checkCommand(COMMAND_TYPE.EDIT, "edit");
		
		checkCommand(COMMAND_TYPE.UNDO, "undo");
		
		checkCommand(COMMAND_TYPE.SEARCH, "search");
		
		checkCommand(COMMAND_TYPE.VIEW, "view");
		
		checkCommand(COMMAND_TYPE.HELP, "HELP");
		
		checkCommand(COMMAND_TYPE.EXIT, "eXiT");
	}
	
	private void checkCommand (COMMAND_TYPE expected, String input) throws Exception{
    	Field f = parser.getClass().getDeclaredField("_parserLogic");
		f.setAccessible(true);
		ParseLogic pl = (ParseLogic) f.get(parser);
		assertEquals(expected, pl.determineCommandType(input));
	}

}
```
